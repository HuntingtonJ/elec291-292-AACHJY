                 -1   $MODLP51
0000              1   ;--------------------------------------------------------
0000              2   ; Special Function Registers
0000              3   ;--------------------------------------------------------
0000              4   ACC            DATA 0xe0
0000              5   B              DATA 0xf0
0000              6   PSW            DATA 0xd0
0000              7   SP             DATA 0x81
0000              8   SPX            DATA 0xef
0000              9   DPL            DATA 0x82
0000             10   DPH            DATA 0x83
0000             11   DPLB           DATA 0xd4
0000             12   DPHB           DATA 0xd5
0000             13   PAGE           DATA 0xf6
0000             14   AX             DATA 0xe1
0000             15   BX             DATA 0xf7
0000             16   DSPR           DATA 0xe2
0000             17   FIRD           DATA 0xe3
0000             18   MACL           DATA 0xe4
0000             19   MACH           DATA 0xe5
0000             20   PCON           DATA 0x87
0000             21   AUXR           DATA 0x8e
0000             22   AUXR1          DATA 0xa2
0000             23   DPCF           DATA 0xa1
0000             24   CKRL           DATA 0x97
0000             25   CKCKON0        DATA 0x8f
0000             26   CKCKON1        DATA 0xaf
0000             27   CKSEL          DATA 0x85
0000             28   CLKREG         DATA 0xae
0000             29   OSCCON         DATA 0x85
0000             30   IE             DATA 0xa8
0000             31   IEN0           DATA 0xa8
0000             32   IEN1           DATA 0xb1
0000             33   IPH0           DATA 0xb7
0000             34   IP             DATA 0xb8
0000             35   IPL0           DATA 0xb8
0000             36   IPH1           DATA 0xb3
0000             37   IPL1           DATA 0xb2
0000             38   P0             DATA 0x80
0000             39   P1             DATA 0x90
0000             40   P2             DATA 0xa0
0000             41   P3             DATA 0xb0
0000             42   P4             DATA 0xc0
0000             43   P0M0           DATA 0xe6
0000             44   P0M1           DATA 0xe7
0000             45   P1M0           DATA 0xd6
0000             46   P1M1           DATA 0xd7
0000             47   P2M0           DATA 0xce
0000             48   P2M1           DATA 0xcf
0000             49   P3M0           DATA 0xc6
0000             50   P3M1           DATA 0xc7
0000             51   P4M0           DATA 0xbe
0000             52   P4M1           DATA 0xbf
0000             53   SCON           DATA 0x98
0000             54   SBUF           DATA 0x99
0000             55   SADEN          DATA 0xb9
0000             56   SADDR          DATA 0xa9
0000             57   BDRCON         DATA 0x9b
0000             58   BRL            DATA 0x9a
0000             59   TCON           DATA 0x88
0000             60   TMOD           DATA 0x89
0000             61   TCONB          DATA 0x91
0000             62   TL0            DATA 0x8a
0000             63   TH0            DATA 0x8c
0000             64   TL1            DATA 0x8b
0000             65   TH1            DATA 0x8d
0000             66   RL0            DATA 0xf2
0000             67   RL1            DATA 0xf3
0000             68   RH0            DATA 0xf4
0000             69   RH1            DATA 0xf5
0000             70   WDTRST         DATA 0xa6
0000             71   WDTPRG         DATA 0xa7
0000             72   T2CON          DATA 0xc8
0000             73   T2MOD          DATA 0xc9
0000             74   RCAP2H         DATA 0xcb
0000             75   RCAP2L         DATA 0xca
0000             76   TH2            DATA 0xcd
0000             77   TL2            DATA 0xcc
0000             78   SPCON          DATA 0xc3
0000             79   SPSTA          DATA 0xc4
0000             80   SPDAT          DATA 0xc5
0000             81   SSCON          DATA 0x93
0000             82   SSCS           DATA 0x94
0000             83   SSDAT          DATA 0x95
0000             84   SSADR          DATA 0x96
0000             85   KBLS           DATA 0x9c
0000             86   KBE            DATA 0x9d
0000             87   KBF            DATA 0x9e
0000             88   KBMOD          DATA 0x9f
0000             89   BMSEL          DATA 0x92
0000             90   FCON           DATA 0xd2
0000             91   EECON          DATA 0xd2
0000             92   ACSRA          DATA 0xa3
0000             93   ACSRB          DATA 0xab
0000             94   AREF           DATA 0xbd
0000             95   DADC           DATA 0xa4
0000             96   DADI           DATA 0xa5
0000             97   DADL           DATA 0xac
0000             98   DADH           DATA 0xad
0000             99   CCON           DATA 0xd8
0000            100   CMOD           DATA 0xd9
0000            101   CL             DATA 0xe9
0000            102   CH             DATA 0xf9
0000            103   CCAPM0         DATA 0xda
0000            104   CCAPM1         DATA 0xdb
0000            105   CCAPM2         DATA 0xdc
0000            106   CCAPM3         DATA 0xdd
0000            107   CCAPM4         DATA 0xde
0000            108   CCAP0H         DATA 0xfa
0000            109   CCAP1H         DATA 0xfb
0000            110   CCAP2H         DATA 0xfc
0000            111   CCAP3H         DATA 0xfd
0000            112   CCAP4H         DATA 0xfe
0000            113   CCAP0L         DATA 0xea
0000            114   CCAP1L         DATA 0xeb
0000            115   CCAP2L         DATA 0xec
0000            116   CCAP3L         DATA 0xed
0000            117   CCAP4L         DATA 0xee
0000            118   ;--------------------------------------------------------
0000            119   ; special function bits
0000            120   ;--------------------------------------------------------
0000            121   P              BIT 0xd0
0000            122   F1             BIT 0xd1
0000            123   OV             BIT 0xd2
0000            124   RS0            BIT 0xd3
0000            125   RS1            BIT 0xd4
0000            126   F0             BIT 0xd5
0000            127   AC             BIT 0xd6
0000            128   CY             BIT 0xd7
0000            129   EX0            BIT 0xa8
0000            130   ET0            BIT 0xa9
0000            131   EX1            BIT 0xaa
0000            132   ET1            BIT 0xab
0000            133   ES             BIT 0xac
0000            134   ET2            BIT 0xad
0000            135   EC             BIT 0xae
0000            136   EA             BIT 0xaf
0000            137   PX0            BIT 0xb8
0000            138   PT0            BIT 0xb9
0000            139   PX1            BIT 0xba
0000            140   PT1            BIT 0xbb
0000            141   PS             BIT 0xbc
0000            142   PT2            BIT 0xbd
0000            143   IP0D           BIT 0xbf
0000            144   PPCL           BIT 0xbe
0000            145   PT2L           BIT 0xbd
0000            146   PLS            BIT 0xbc
0000            147   PT1L           BIT 0xbb
0000            148   PX1L           BIT 0xba
0000            149   PT0L           BIT 0xb9
0000            150   PX0L           BIT 0xb8
0000            151   RXD            BIT 0xb0
0000            152   TXD            BIT 0xb1
0000            153   INT0           BIT 0xb2
0000            154   INT1           BIT 0xb3
0000            155   T0             BIT 0xb4
0000            156   T1             BIT 0xb5
0000            157   WR             BIT 0xb6
0000            158   RD             BIT 0xb7
0000            159   RI             BIT 0x98
0000            160   TI             BIT 0x99
0000            161   RB8            BIT 0x9a
0000            162   TB8            BIT 0x9b
0000            163   REN            BIT 0x9c
0000            164   SM2            BIT 0x9d
0000            165   SM1            BIT 0x9e
0000            166   SM0            BIT 0x9f
0000            167   IT0            BIT 0x88
0000            168   IE0            BIT 0x89
0000            169   IT1            BIT 0x8a
0000            170   IE1            BIT 0x8b
0000            171   TR0            BIT 0x8c
0000            172   TF0            BIT 0x8d
0000            173   TR1            BIT 0x8e
0000            174   TF1            BIT 0x8f
0000            175   CP_RL2         BIT 0xc8
0000            176   C_T2           BIT 0xc9
0000            177   TR2            BIT 0xca
0000            178   EXEN2          BIT 0xcb
0000            179   TCLK           BIT 0xcc
0000            180   RCLK           BIT 0xcd
0000            181   EXF2           BIT 0xce
0000            182   TF2            BIT 0xcf
0000            183   CF             BIT 0xdf
0000            184   CR             BIT 0xde
0000            185   CCF4           BIT 0xdc
0000            186   CCF3           BIT 0xdb
0000            187   CCF2           BIT 0xda
0000            188   CCF1           BIT 0xd9
0000            189   CCF0           BIT 0xd8
0000              2   
0000              3   ; There is a couple of typos in MODLP51 in the definition of the timer 0/1 reload
0000              4   ; special function registers (SFRs), so:
0000              5   
0000              6   TIMER0_RELOAD_L DATA 0xf2
0000              7   TIMER1_RELOAD_L DATA 0xf3
0000              8   TIMER0_RELOAD_H DATA 0xf4
0000              9   TIMER1_RELOAD_H DATA 0xf5
0000             10   
0000             11   CLK              EQU 22118400 ; Microcontroller system crystal frequency in Hz
0000             12   TIMER0_RATE      EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             13   TIMER0_RELOAD    EQU ((65536-(CLK/TIMER0_RATE)))
0000             14   TIMER2_RATE      EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             15   TIMER2_RELOAD    EQU ((65536-(CLK/TIMER2_RATE)))
0000             16   MAX_TEMP              EQU 250
0000             17   TIMEOUT_TIME     EQU 60
0000             18   BAUD             EQU 115200
0000             19   BRG_VAL          EQU (0x100-(CLK/(16*BAUD)))
0000             20   MILLISECOND_WAIT EQU 200                 ; how many milliseconds between temp samples
0000             21   
0000             22   DUTY_0           EQU 0
0000             23   DUTY_20          EQU 51   ;256 * 0.2
0000             24   DUTY_50          EQU 128  ;256 * 0.5
0000             25   DUTY_80          EQU 204  ;256 * 0.8
0000             26   DUTY_100         EQU 255
0000             27   
0000             28   org 0x0000
0000 021434      29      ljmp MainProgram
0003             30   
0003             31   ; External interrupt 0 vector (not used in this code)
0003             32   org 0x0003
0003 32          33            reti
0004             34   
0004             35   ; Timer/Counter 0 overflow interrupt vector
000B             36   org 0x000B
000B 02131C      37            ljmp Timer0_ISR
000E             38   
000E             39   ; External interrupt 1 vector (not used in this code)
0013             40   org 0x0013
0013 32          41            reti
0014             42   
0014             43   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             44   org 0x001B
001B 32          45            reti
001C             46   
001C             47   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             48   org 0x0023 
0023 32          49            reti
0024             50            
0024             51   ; Timer/Counter 2 overflow interrupt vector
002B             52   org 0x002B
002B 021357      53            ljmp Timer2_ISR
002E             54   
002E             55   ;Edge triggered keyboard interrupt vector
003B             56   org 0x003B
003B 0213A1      57            ljmp Start_stop_ISR
003E             58   
003E             59   ; These ’EQU’ must match the wiring between the microcontroller and ADC
003E             60   SOUND_OUT     EQU P3.7
003E             61   CE_ADC        EQU P2.4
003E             62   MY_MOSI       EQU P2.5
003E             63   MY_MISO       EQU P2.6
003E             64   MY_SCLK       EQU P2.7
003E             65   
003E             66   UP_BUTTON          EQU P0.0
003E             67   DOWN_BUTTON   EQU P0.1
003E             68   SELECT_BUTTON EQU P0.2
003E             69   NEXT_BUTTON   EQU P0.3
003E             70   BACK_BUTTON   EQU p0.4
003E             71   
003E             72   MASTER_START  EQU p1.0
003E             73   
003E             74   MASTER_STOP   EQU p0.5
003E             75   
003E             76   
0030             77   DSEG at 0x30
0030             78   Count1ms:       ds 2 ; Used to determine when half second has passed
0032             79   Result:         ds 2 ; Temp from lm355
0034             80   Result_Thermo:  ds 2 ; Temp from Thermocoupler
0036             81   BCD_temp:       ds 2 ; Used to diplay temp on the 7-segment display
0038             82   seconds:        ds 1
0039             83   x:              ds 4 ; Used in math32
003D             84   y:              ds 4 ; Used in math32
0041             85   bcd:            ds 5
0046             86   soaktime:       ds 2
0048             87   soaktemp:       ds 2
004A             88   reflowtime:     ds 2
004C             89   reflowtemp:     ds 2
004E             90   soaktemp3digit: ds 2
0050             91   reflow_state:   ds 1
0051             92   pwm:            ds 1
0052             93   temp:           ds 1
0053             94   sec:            ds 1 ; seconds variable for reflow FSM (to be incremented every second)
0054             95   cooled_temp:    ds 1
0055             96   ; 7-segment vars
0055             97   Disp1:          ds 1 ; Least significant digit
0056             98   Disp2:          ds 1
0057             99   Disp3:          ds 1 ; Most significant digit
0058            100   seg_state:      ds 1 ; state of 7_seg fsm
0059            101   
0059            102   
0059            103   
0000            104   BSEG
0000            105   mf: dbit 1
0001            106   one_second_flag: dbit 1 
0002            107   
0002            108   
003E            109   CSEG
003E            110   LCD_RS equ P1.1
003E            111   LCD_RW equ P1.2
003E            112   LCD_E  equ P1.3
003E            113   LCD_D4 equ P3.2
003E            114   LCD_D5 equ P3.3
003E            115   LCD_D6 equ P3.4
003E            116   LCD_D7 equ P3.6
003E            117                    ;                        1234567890123456
003E 20202020   118   Ramp_to_Soak:    db       '        Preheat', 0
     20202020
     50726568
     65617400
004E 20202020   119   Soak:                    db   '        Soak   ', 0
     20202020
     536F616B
     20202000
005E 20202020   120   Ramp_to_Peak:    db       '        Ramp2pk', 0
     20202020
     52616D70
     32706B00
006E 20202020   121   Reflow:                  db       '        Reflow ', 0
     20202020
     5265666C
     6F772000
007E 20202020   122   Cooling:                 db       '        Cooling', 0
     20202020
     436F6F6C
     696E6700
008E 7300       123   secondsss:               db   's'                , 0
0090            124   ;                     1234567890123456    <- This helps determine the location of the counter
0090 57656C63   125   Welcome:                   db 'Welcome!        ', 0
     6F6D6521
     20202020
     20202020
     00
00A1 53656C65   126   Choose_option:     db 'Select option   ', 0
     6374206F
     7074696F
     6E202020
     00
00B2 50726573   127   Preset_menu_msg:  db 'Preset Profile  ', 0
     65742050
     726F6669
     6C652020
     00
00C3 43757374   128   Custom_menu_msg:  db 'Custom Profile  ', 0
     6F6D2050
     726F6669
     6C652020
     00
00D4 536F616B   129   Soak_temp:                 db 'Soak Temp       ', 0
     2054656D
     70202020
     20202020
     00
00E5 536F616B   130   Soak_time:                 db 'Soak Time       ', 0
     2054696D
     65202020
     20202020
     00
00F6 5265666C   131   Reflow_time:       db 'Reflow Time     ', 0
     6F772054
     696D6520
     20202020
     00
0107 5265666C   132   Reflow_temp:       db 'Reflow Temp     ', 0
     6F772054
     656D7020
     20202020
     00
0118 53414333   133   Pb_free_solder:    db 'SAC305 solder   ', 0
     30352073
     6F6C6465
     72202020
     00
0129 50622D73   134   Pb_solder:                 db 'Pb-solder paste ', 0
     6F6C6465
     72207061
     73746520
     00
013A 53686868   135   Pizza_msg0:        db 'Shhh! No pizza  ', 0
     21204E6F
     2070697A
     7A612020
     00
014B 616C6C6F   136   Pizza_msg1:        db 'allowed in here.', 0
     77656420
     696E2068
     6572652E
     00
015C 70726F66   137   Profile_loaded:   db 'profile loaded  ', 0
     696C6520
     6C6F6164
     65642020
     00
016D 53797374   138   Is_ready:                  db 'System Ready    ', 0
     656D2052
     65616479
     20202020
     00
017E 50726573   139   Press_start:       db 'Press Start     ', 0
     73205374
     61727420
     20202020
     00
018F 78782020   140   Set_Value:                 db 'xx              ', 0
     20202020
     20202020
     20202020
     00
01A0 20202020   141   Clear_Row:                 db '                ', 0
     20202020
     20202020
     20202020
     00
01B1 41542050   142   PRESETMENUMSG:     db 'AT PRESET MENU  ', 0
     52455345
     54204D45
     4E552020
     00
01C2 41542043   143   CUSTOMMENUMSG:     db 'AT CUSTOM MENU  ', 0
     5553544F
     4D204D45
     4E552020
     00
01D3 41726520   144   Are_you_sure:      db 'Are you sure?   ', 0
     796F7520
     73757265
     3F202020
     00
01E4 4572726F   145   Error_msg1:        db 'Error, profiles ', 0
     722C2070
     726F6669
     6C657320
     00
01F5 6E6F7420   146   Error_msg2:       db 'not loaded      ', 0
     6C6F6164
     65642020
     20202020
     00
0206 50726F63   147   Abort_string:      db 'Process aborted ', 0
     65737320
     61626F72
     74656420
     00
0217 57616974   148   Waiting_to_cool:  db 'Wait to cool    ', 0
     20746F20
     636F6F6C
     20202020
     00
0228 49535220   149   ISR_is_running:   db 'ISR is running  ', 0
     69732072
     756E6E69
     6E672020
     00
0239            150   
0239 53746174   151   State_0: db 'State 0', 0
     65203000
0241 53746174   152   State_1: db 'State 1', 0
     65203100
0249            153   
0249            154   
                156   	$LIST
02F7            158   
                160   $LIST
0A79            162   
                546   $LIST
                  4   $LIST
0CE9              6   
                  7   Send_BCD mac
                  8   	push ar0
                  9   	mov r0, %0
                 10   	lcall ?Send_BCD
                 11   	mov a, #'\r'
                 12       lcall putchar
                 13       mov a, #'\n'
                 14       lcall putchar
                 15   	pop ar0
                 16   endmac
0CE9             17   
0CE9             18   ; Configure the serial port and baud rate
0CE9             19   InitSerialPort:
0CE9             20       ; Since the reset button bounces, we need to wait a bit before
0CE9             21       ; sending messages, otherwise we risk displaying gibberish!
0CE9 79DE        22       mov R1, #222
0CEB 78A6        23       mov R0, #166
0CED D8FE        24       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
0CEF D9FA        25       djnz R1, $-4 ; 22.51519us*222=4.998ms
0CF1             26       ; Now we can proceed with the configuration
0CF1 438780      27            orl     PCON,#0x80
0CF4 759852      28            mov     SCON,#0x52
0CF7 759B00      29            mov     BDRCON,#0x00
0CFA 759AF4      30            mov     BRL,#BRG_VAL
0CFD 759B1E      31            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0D00 22          32       ret
0D01             33   
0D01             34   ; Send a character using the serial port
0D01             35   putchar:
0D01 3099FD      36       jnb TI, putchar
0D04 C299        37       clr TI
0D06 F599        38       mov SBUF, a
0D08 22          39       ret
0D09             40   
0D09             41   ; Send a constant-zero-terminated string using the serial port
0D09             42   SendString:
0D09 E4          43       clr A
0D0A 93          44       movc A, @A+DPTR
0D0B 6006        45       jz SendStringDone
0D0D 120D01      46       lcall putchar
0D10 A3          47       inc DPTR
0D11 80F6        48       sjmp SendString
0D13             49   SendStringDone:
0D13 22          50       ret
0D14             51       
0D14             52   INIT_SPI:
0D14 D2A6        53            setb MY_MISO ; Make MISO an input pin
0D16 C2A7        54            clr MY_SCLK ; For mode (0,0) SCLK is zero
0D18 22          55            ret
0D19             56   
0D19             57   DO_SPI_G:
0D19 C0E0        58            push acc
0D1B 7900        59            mov R1, #0 ; Received byte stored in R1
0D1D 7A08        60            mov R2, #8 ; Loop counter (8-bits)
0D1F             61   DO_SPI_G_LOOP:
0D1F E8          62            mov a, R0 ; Byte to write is in R0
0D20 33          63            rlc a ; Carry flag has bit to write
0D21 F8          64            mov R0, a
0D22 92A5        65            mov MY_MOSI, c
0D24 D2A7        66            setb MY_SCLK ; Transmit
0D26 A2A6        67            mov c, MY_MISO ; Read received bit
0D28 E9          68            mov a, R1 ; Save received bit in R1
0D29 33          69            rlc a
0D2A F9          70            mov R1, a
0D2B C2A7        71            clr MY_SCLK
0D2D DAF0        72            djnz R2, DO_SPI_G_LOOP
0D2F D0E0        73            pop acc
0D31 22          74            ret
0D32             75    
0D32             76   Hello_World:
0D32 48656C6C    77       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
0D42             78       
0D42             79   Delay:
0D42 79DE        80            mov R1, #222
0D44 78A6        81       mov R0, #166
0D46 D8FE        82       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
0D48 D9FA        83       djnz R1, $-4 ; 22.51519us*222=4.998ms
0D4A 32          84       reti
0D4B             85       
                 86   Left_blank mac
                 87   	mov a, %0
                 88   	anl a, #0xf0
                 89   	swap a
                 90   	jz Left_blank_%M_a
                 91   	ljmp %1
                 92   Left_blank_%M_a:
                 93   	Display_char(#' ')
                 94   	mov a, %0
                 95   	anl a, #0x0f
                 96   	jz Left_blank_%M_b
                 97   	ljmp %1
                 98   Left_blank_%M_b:
                 99   	Display_char(#' ')
                100   endmac
0D4B            101      
0D4B            102   ; Sends 10-digit BCD number in bcd to the LCD 
0D4B            103   Display_10_digit_BCD:
0D4B C0E0       104            push acc
0D4D 7407       104            mov a, #7
0D4F 14         104            dec a
0D50 1202DA     104            lcall ?Set_Cursor_2 ; Select column and row
0D53 D0E0       104            pop acc
0D55 C000       105            push ar0
0D57 A845       105            mov r0, bcd+4
0D59 1202E1     105            lcall ?Display_BCD
0D5C D000       105            pop ar0
0D5E C000       106            push ar0
0D60 A844       106            mov r0, bcd+3
0D62 1202E1     106            lcall ?Display_BCD
0D65 D000       106            pop ar0
0D67 C000       107            push ar0
0D69 A843       107            mov r0, bcd+2
0D6B 1202E1     107            lcall ?Display_BCD
0D6E D000       107            pop ar0
0D70 C000       108            push ar0
0D72 A842       108            mov r0, bcd+1
0D74 1202E1     108            lcall ?Display_BCD
0D77 D000       108            pop ar0
0D79 C000       109            push ar0
0D7B A841       109            mov r0, bcd+0
0D7D 1202E1     109            lcall ?Display_BCD
0D80 D000       109            pop ar0
0D82            110            ; Replace all the zeros to the left with blanks
0D82 C0E0       111            push acc
0D84 7407       111            mov a, #7
0D86 14         111            dec a
0D87 1202DA     111            lcall ?Set_Cursor_2 ; Select column and row
0D8A D0E0       111            pop acc
0D8C E545       112            mov a, bcd+4
0D8E 54F0       112            anl a, #0xf0
0D90 C4         112            swap a
0D91 6003       112            jz Left_blank_141_a
0D93 020E30     112            ljmp skip_blank
0D96            112   Left_blank_141_a:
0D96 C0E0       112            push acc
0D98 7420       112            mov a, #' '
0D9A 120299     112            lcall ?WriteData
0D9D D0E0       112            pop acc
0D9F E545       112            mov a, bcd+4
0DA1 540F       112            anl a, #0x0f
0DA3 6003       112            jz Left_blank_141_b
0DA5 020E30     112            ljmp skip_blank
0DA8            112   Left_blank_141_b:
0DA8 C0E0       112            push acc
0DAA 7420       112            mov a, #' '
0DAC 120299     112            lcall ?WriteData
0DAF D0E0       112            pop acc
0DB1 E544       113            mov a, bcd+3
0DB3 54F0       113            anl a, #0xf0
0DB5 C4         113            swap a
0DB6 6003       113            jz Left_blank_144_a
0DB8 020E30     113            ljmp skip_blank
0DBB            113   Left_blank_144_a:
0DBB C0E0       113            push acc
0DBD 7420       113            mov a, #' '
0DBF 120299     113            lcall ?WriteData
0DC2 D0E0       113            pop acc
0DC4 E544       113            mov a, bcd+3
0DC6 540F       113            anl a, #0x0f
0DC8 6003       113            jz Left_blank_144_b
0DCA 020E30     113            ljmp skip_blank
0DCD            113   Left_blank_144_b:
0DCD C0E0       113            push acc
0DCF 7420       113            mov a, #' '
0DD1 120299     113            lcall ?WriteData
0DD4 D0E0       113            pop acc
0DD6 E543       114            mov a, bcd+2
0DD8 54F0       114            anl a, #0xf0
0DDA C4         114            swap a
0DDB 6003       114            jz Left_blank_147_a
0DDD 020E30     114            ljmp skip_blank
0DE0            114   Left_blank_147_a:
0DE0 C0E0       114            push acc
0DE2 7420       114            mov a, #' '
0DE4 120299     114            lcall ?WriteData
0DE7 D0E0       114            pop acc
0DE9 E543       114            mov a, bcd+2
0DEB 540F       114            anl a, #0x0f
0DED 6003       114            jz Left_blank_147_b
0DEF 020E30     114            ljmp skip_blank
0DF2            114   Left_blank_147_b:
0DF2 C0E0       114            push acc
0DF4 7420       114            mov a, #' '
0DF6 120299     114            lcall ?WriteData
0DF9 D0E0       114            pop acc
0DFB E542       115            mov a, bcd+1
0DFD 54F0       115            anl a, #0xf0
0DFF C4         115            swap a
0E00 6003       115            jz Left_blank_150_a
0E02 020E30     115            ljmp skip_blank
0E05            115   Left_blank_150_a:
0E05 C0E0       115            push acc
0E07 7420       115            mov a, #' '
0E09 120299     115            lcall ?WriteData
0E0C D0E0       115            pop acc
0E0E E542       115            mov a, bcd+1
0E10 540F       115            anl a, #0x0f
0E12 6003       115            jz Left_blank_150_b
0E14 020E30     115            ljmp skip_blank
0E17            115   Left_blank_150_b:
0E17 C0E0       115            push acc
0E19 7420       115            mov a, #' '
0E1B 120299     115            lcall ?WriteData
0E1E D0E0       115            pop acc
0E20 E541       116            mov a, bcd+0
0E22 54F0       117            anl a, #0f0h
0E24 C4         118            swap a
0E25 7009       119            jnz skip_blank
0E27 C0E0       120            push acc
0E29 7420       120            mov a, #' '
0E2B 120299     120            lcall ?WriteData
0E2E D0E0       120            pop acc
0E30            121   skip_blank:
0E30 22         122            ret
0E31            123            
0E31            124   Display_10_digit_BCD_2:
0E31 C0E0       125            push acc
0E33 7407       125            mov a, #7
0E35 14         125            dec a
0E36 1202DC     125            lcall ?Set_Cursor_1 ; Select column and row
0E39 D0E0       125            pop acc
0E3B C000       126            push ar0
0E3D A845       126            mov r0, bcd+4
0E3F 1202E1     126            lcall ?Display_BCD
0E42 D000       126            pop ar0
0E44 C000       127            push ar0
0E46 A844       127            mov r0, bcd+3
0E48 1202E1     127            lcall ?Display_BCD
0E4B D000       127            pop ar0
0E4D C000       128            push ar0
0E4F A843       128            mov r0, bcd+2
0E51 1202E1     128            lcall ?Display_BCD
0E54 D000       128            pop ar0
0E56 C000       129            push ar0
0E58 A842       129            mov r0, bcd+1
0E5A 1202E1     129            lcall ?Display_BCD
0E5D D000       129            pop ar0
0E5F C000       130            push ar0
0E61 A841       130            mov r0, bcd+0
0E63 1202E1     130            lcall ?Display_BCD
0E66 D000       130            pop ar0
0E68            131            ; Replace all the zeros to the left with blanks
0E68 C0E0       132            push acc
0E6A 7407       132            mov a, #7
0E6C 14         132            dec a
0E6D 1202DC     132            lcall ?Set_Cursor_1 ; Select column and row
0E70 D0E0       132            pop acc
0E72 E545       133            mov a, bcd+4
0E74 54F0       133            anl a, #0xf0
0E76 C4         133            swap a
0E77 6003       133            jz Left_blank_161_a
0E79 020F16     133            ljmp skip_blank_2
0E7C            133   Left_blank_161_a:
0E7C C0E0       133            push acc
0E7E 7420       133            mov a, #' '
0E80 120299     133            lcall ?WriteData
0E83 D0E0       133            pop acc
0E85 E545       133            mov a, bcd+4
0E87 540F       133            anl a, #0x0f
0E89 6003       133            jz Left_blank_161_b
0E8B 020F16     133            ljmp skip_blank_2
0E8E            133   Left_blank_161_b:
0E8E C0E0       133            push acc
0E90 7420       133            mov a, #' '
0E92 120299     133            lcall ?WriteData
0E95 D0E0       133            pop acc
0E97            133   
0E97 E544       134            mov a, bcd+3
0E99 54F0       134            anl a, #0xf0
0E9B C4         134            swap a
0E9C 6003       134            jz Left_blank_164_a
0E9E 020F16     134            ljmp skip_blank_2
0EA1            134   Left_blank_164_a:
0EA1 C0E0       134            push acc
0EA3 7420       134            mov a, #' '
0EA5 120299     134            lcall ?WriteData
0EA8 D0E0       134            pop acc
0EAA E544       134            mov a, bcd+3
0EAC 540F       134            anl a, #0x0f
0EAE 6003       134            jz Left_blank_164_b
0EB0 020F16     134            ljmp skip_blank_2
0EB3            134   Left_blank_164_b:
0EB3 C0E0       134            push acc
0EB5 7420       134            mov a, #' '
0EB7 120299     134            lcall ?WriteData
0EBA D0E0       134            pop acc
0EBC E543       135            mov a, bcd+2
0EBE 54F0       135            anl a, #0xf0
0EC0 C4         135            swap a
0EC1 6003       135            jz Left_blank_167_a
0EC3 020F16     135            ljmp skip_blank_2
0EC6            135   Left_blank_167_a:
0EC6 C0E0       135            push acc
0EC8 7420       135            mov a, #' '
0ECA 120299     135            lcall ?WriteData
0ECD D0E0       135            pop acc
0ECF E543       135            mov a, bcd+2
0ED1 540F       135            anl a, #0x0f
0ED3 6003       135            jz Left_blank_167_b
0ED5 020F16     135            ljmp skip_blank_2
0ED8            135   Left_blank_167_b:
0ED8 C0E0       135            push acc
0EDA 7420       135            mov a, #' '
0EDC 120299     135            lcall ?WriteData
0EDF D0E0       135            pop acc
0EE1 E542       136            mov a, bcd+1
0EE3 54F0       136            anl a, #0xf0
0EE5 C4         136            swap a
0EE6 6003       136            jz Left_blank_170_a
0EE8 020F16     136            ljmp skip_blank_2
0EEB            136   Left_blank_170_a:
0EEB C0E0       136            push acc
0EED 7420       136            mov a, #' '
0EEF 120299     136            lcall ?WriteData
0EF2 D0E0       136            pop acc
0EF4 E542       136            mov a, bcd+1
0EF6 540F       136            anl a, #0x0f
0EF8 6003       136            jz Left_blank_170_b
0EFA 020F16     136            ljmp skip_blank_2
0EFD            136   Left_blank_170_b:
0EFD C0E0       136            push acc
0EFF 7420       136            mov a, #' '
0F01 120299     136            lcall ?WriteData
0F04 D0E0       136            pop acc
0F06 E541       137            mov a, bcd+0
0F08 54F0       138            anl a, #0f0h
0F0A C4         139            swap a
0F0B 7009       140            jnz skip_blank_2
0F0D C0E0       141            push acc
0F0F 7420       141            mov a, #' '
0F11 120299     141            lcall ?WriteData
0F14 D0E0       141            pop acc
0F16            142   skip_blank_2:
0F16 22         143            ret
0F17            144   
0F17            145            ; Sends 10-digit BCD number in BCD to the SPI
0F17            146   Send_10_digit_BCD:
0F17 C000       147            push ar0
0F19 A845       147            mov r0, bcd+4
0F1B 120F77     147            lcall ?Send_BCD
0F1E 740D       147            mov a, #'\r'
0F20 120D01     147       lcall putchar
0F23 740A       147       mov a, #'\n'
0F25 120D01     147       lcall putchar
0F28 D000       147            pop ar0
0F2A C000       148            push ar0
0F2C A844       148            mov r0, bcd+3
0F2E 120F77     148            lcall ?Send_BCD
0F31 740D       148            mov a, #'\r'
0F33 120D01     148       lcall putchar
0F36 740A       148       mov a, #'\n'
0F38 120D01     148       lcall putchar
0F3B D000       148            pop ar0
0F3D C000       149            push ar0
0F3F A843       149            mov r0, bcd+2
0F41 120F77     149            lcall ?Send_BCD
0F44 740D       149            mov a, #'\r'
0F46 120D01     149       lcall putchar
0F49 740A       149       mov a, #'\n'
0F4B 120D01     149       lcall putchar
0F4E D000       149            pop ar0
0F50 C000       150            push ar0
0F52 A842       150            mov r0, bcd+1
0F54 120F77     150            lcall ?Send_BCD
0F57 740D       150            mov a, #'\r'
0F59 120D01     150       lcall putchar
0F5C 740A       150       mov a, #'\n'
0F5E 120D01     150       lcall putchar
0F61 D000       150            pop ar0
0F63 C000       151            push ar0
0F65 A841       151            mov r0, bcd+0
0F67 120F77     151            lcall ?Send_BCD
0F6A 740D       151            mov a, #'\r'
0F6C 120D01     151       lcall putchar
0F6F 740A       151       mov a, #'\n'
0F71 120D01     151       lcall putchar
0F74 D000       151            pop ar0
0F76 22         152            ret
0F77            153   
0F77            154   ?Send_BCD:
0F77 C0E0       155            push acc
0F79            156            ; Write most significant digit
0F79 E8         157            mov a, r0
0F7A C4         158            swap a
0F7B 540F       159            anl a, #0fh
0F7D 4430       160            orl a, #30h
0F7F 120D01     161            lcall putchar
0F82            162            ; write least significant digit
0F82 E8         163            mov a, r0
0F83 540F       164            anl a, #0fh
0F85 4430       165            orl a, #30h
0F87 120D01     166            lcall putchar
0F8A D0E0       167            pop acc
0F8C 22         168            ret
0F8D            169   
0F8D            170   GET_ADC_TEMP:
0F8D C2A4       171       clr CE_ADC         ; selects 
0F8F 7801       172       mov R0, #00000001B ; Start bit: 1
0F91 120D19     173       lcall DO_SPI_G
0F94            174       
0F94 7880       175       mov R0, #10000000B ; Read channel 0
0F96 120D19     176       lcall DO_SPI_G
0F99 E9         177       mov a, R1
0F9A 5403       178       anl a, #00000011B
0F9C F533       179       mov Result+1, a    ; Save high result
0F9E            180       
0F9E 7855       181       mov R0, #55H
0FA0 120D19     182       lcall DO_SPI_G
0FA3 8932       183       mov Result, R1     ; Save low result
0FA5            184       
0FA5 D2A4       185       setb CE_ADC        ; deselects
0FA7            186       
0FA7            187       ;V_OUT = ADC_voltage*4.096V/1023
0FA7            188       ;ADC_voltage*4096 = A
0FA7 853239     189       mov x+0, Result
0FAA 85333A     190       mov x+1, Result+1
0FAD 753B00     191       mov x+2, #0
0FB0 753C00     192       mov x+3, #0
0FB3            193       
0FB3 22         194    ret
0FB4            195   
0FB4            196    GET_THERMO_TEMP:
0FB4 C2A4       197       clr CE_ADC         ; selects 
0FB6 7801       198       mov R0, #00000001B ; Start bit: 1
0FB8 120D19     199       lcall DO_SPI_G
0FBB            200       
0FBB 7890       201       mov R0, #10010000B ; Read channel 1
0FBD 120D19     202       lcall DO_SPI_G
0FC0 E9         203       mov a, R1
0FC1 5403       204       anl a, #00000011B
0FC3 F535       205       mov Result_Thermo+1, a    ; Save high result
0FC5            206       
0FC5 7855       207       mov R0, #55H
0FC7 120D19     208       lcall DO_SPI_G
0FCA 8934       209       mov Result_Thermo, R1     ; Save low result
0FCC D2A4       210       setb CE_ADC        ; deselects
0FCE            211       
0FCE            212       ;V_OUT = ADC_voltage*4.096V/1023
0FCE            213       ;ADC_voltage*4096 = A
0FCE 853439     214       mov x+0, Result_Thermo
0FD1 85353A     215       mov x+1, Result_Thermo+1
0FD4 753B00     216       mov x+2, #0
0FD7 753C00     217       mov x+3, #0
0FDA 22         218     ret
0FDB            219   
0FDB            220   ;____________________________________
0FDB            221    ;*************************************
0FDB            222   
0FDB            223   ; This is the code that converts the amplified voltage from the the k-type thermocouple 
0FDB            224   ; to temperature data for use. 
0FDB            225   ; Current Parameters: 
0FDB            226   ;                Op-amp gain: ~200
0FDB            227   ;                Thermocouple conversion: 41 uV/celcius
0FDB            228   ;                Reference Voltage: 4.096 
0FDB            229   ; inputs
0FDB            230   ;*************************************           
0FDB            231   ;-------------------------------------           
0FDB            232   
0FDB            233   Voltage_to_temp_LM355: 
0FDB 753D00     234            mov y+0, #low (4096 % 0x10000) 
0FDE 753E10     234            mov y+1, #high(4096 % 0x10000) 
0FE1 753F00     234            mov y+2, #low (4096 / 0x10000) 
0FE4 754000     234            mov y+3, #high(4096 / 0x10000) 
0FE7 120BF3     235                        lcall mul32 ;multiplies x *= y
0FEA            236                        
0FEA            237                        ;A/1023 = B
0FEA 753DFF     238            mov y+0, #low (1023 % 0x10000) 
0FED 753E03     238            mov y+1, #high(1023 % 0x10000) 
0FF0 753F00     238            mov y+2, #low (1023 / 0x10000) 
0FF3 754000     238            mov y+3, #high(1023 / 0x10000) 
0FF6 120C80     239                        lcall div32 ;divides x /= y
0FF9            240                        
0FF9            241                        ;B - 2730 = C
0FF9 753DAA     242            mov y+0, #low (2730 % 0x10000) 
0FFC 753E0A     242            mov y+1, #high(2730 % 0x10000) 
0FFF 753F00     242            mov y+2, #low (2730 / 0x10000) 
1002 754000     242            mov y+3, #high(2730 / 0x10000) ;
1005 120B5F     243                        lcall sub32
1008            244                        
1008            245                        ;B/10 = V_OUT
1008 753D0A     246            mov y+0, #low (10 % 0x10000) 
100B 753E00     246            mov y+1, #high(10 % 0x10000) 
100E 753F00     246            mov y+2, #low (10 / 0x10000) 
1011 754000     246            mov y+3, #high(10 / 0x10000) ;
1014 120C80     247                        lcall div32 ;divides x /= y
1017 120A79     248                            lcall hex2bcd
101A 22         249            ret
101B            250   
101B            251   Voltage_to_temp_thermocouple: 
101B            252   
101B            253            ;SPI_REF_VOLTAGE_mul100 equ 4081
101B            254            ;THERMOCOUPLE_CONVERSION_div1000 equ 2475
101B            255            
101B            256            ;
101B            257            ; We are doing the conversion from V--> 10 bit Temp (deg C)
101B            258            ; Start: Amplified Volts, Vin
101B            259            ;
101B            260            ;               Vin*(1 deg C)* (V_REF)*    1    * 1
101B            261            ;                        --------                           ---    ---  - ADC_RESULT
101B            262            ;                       (41 uV )                   OP_AMP_GAIn  1023
101B            263   
101B 753DF1     264            mov y+0, #low (4081 % 0x10000) 
101E 753E0F     264            mov y+1, #high(4081 % 0x10000) 
1021 753F00     264            mov y+2, #low (4081 / 0x10000) 
1024 754000     264            mov y+3, #high(4081 / 0x10000) ; 4.081*1000=mV
1027 120BF3     265            lcall mul32
102A            266            
102A 753DFF     267            mov y+0, #low (1023 % 0x10000) 
102D 753E03     267            mov y+1, #high(1023 % 0x10000) 
1030 753F00     267            mov y+2, #low (1023 / 0x10000) 
1033 754000     267            mov y+3, #high(1023 / 0x10000) 
1036 120C80     268            lcall div32   
1039            269            
1039 753DF7     270            mov y+0, #low (247 % 0x10000) 
103C 753E00     270            mov y+1, #high(247 % 0x10000) 
103F 753F00     270            mov y+2, #low (247 / 0x10000) 
1042 754000     270            mov y+3, #high(247 / 0x10000)  ; 24.75*10
1045 120BF3     271            lcall mul32
1048            272                                    ;---------
1048 753D02     273            mov y+0, #low (2050 % 0x10000) 
104B 753E08     273            mov y+1, #high(2050 % 0x10000) 
104E 753F00     273            mov y+2, #low (2050 / 0x10000) 
1051 754000     273            mov y+3, #high(2050 / 0x10000)  ; 205*10
1054 120C80     274            lcall div32
1057            275            
1057 753D16     276            mov y+0, #low (22 % 0x10000) 
105A 753E00     276            mov y+1, #high(22 % 0x10000) 
105D 753F00     276            mov y+2, #low (22 / 0x10000) 
1060 754000     276            mov y+3, #high(22 / 0x10000) 
1063            277   
1063            278   
1063 120B3E     279            lcall add32
1066            280            
1066 120A79     281            lcall hex2bcd
1069 22         282      ret
106A            283   
106A            284   
106A            285   GET_TEMP_DATA: 
106A 300111     286            jnb one_second_flag, GET_TEMP_DATA_END
106D C201       287            clr one_second_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
106F            288            
106F            289            ;Gets, displays, and pushes ADC LM355 temp values
106F 120F8D     290            lcall GET_ADC_TEMP
1072 120FDB     291       lcall Voltage_to_temp_LM355
1075 120D4B     292       lcall Display_10_digit_BCD
1078            293       
1078            294       ; Gets, displays, and pushes k-type thermocouple vlaues
1078 120FB4     295            lcall GET_THERMO_TEMP
107B 12101B     296       lcall Voltage_to_temp_thermocouple
107E            297       ;lcall Send_10_digit_BCD
107E            298       ;lcall Display_10_digit_BCD_2
107E            299       
107E            300       ;lcall Delay
107E            301    GET_TEMP_DATA_END:
107E 22         302       ret
107F            303            
107F            304   
107F            305   
107F            306   EN
                164   $LIST
107F            166   
                168   $LIST
1303            170   
1303            171   ;$NOLIST
1303            172   ;$include(7_segment.asm) ; A library of 7 segment displays related functions and utility macros
1303            173   ;$LIST
1303            174   
1303            175   ;----------------------------------------MACRO LOCATION----------------------------------------------
1303            176   
1303            177   
1303            178   
1303            179   
1303            180   ;---------------------------------;
1303            181   ; Routine to initialize the ISR   ;
1303            182   ; for timer 0                     ;
1303            183   ;---------------------------------;
1303            184   Timer0_Init:
1303 E589       185            mov a, TMOD
1305 54F0       186            anl a, #0xf0 ; Clear the bits for timer 0
1307 4401       187            orl a, #0x01 ; Configure timer 0 as 16-timer
1309 F589       188            mov TMOD, a
130B 758CEA     189            mov TH0, #high(TIMER0_RELOAD)
130E 758AE8     190            mov TL0, #low(TIMER0_RELOAD)
1311            191            ; Set autoreload value
1311 75F4EA     192            mov TIMER0_RELOAD_H, #high(TIMER0_RELOAD)
1314 75F2E8     193            mov TIMER0_RELOAD_L, #low(TIMER0_RELOAD)
1317            194            ; Enable the timer and interrupts
1317 D2A9       195       setb ET0  ; Enable timer 0 interrupt
1319 D28C       196       setb TR0  ; Start timer 0
131B 22         197            ret
131C            198   
131C            199   ;---------------------------------;
131C            200   ; ISR for timer 0.  Set to execute;
131C            201   ; every 1/4096Hz to generate a    ;
131C            202   ; 2048 Hz square wave at pin P3.7 ;
131C            203   ;---------------------------------;
131C            204   Timer0_ISR:
131C            205            ;clr TF0  ; According to the data sheet this is done for us already.
131C 8000       206            sjmp no_beep
131E            207   beep_on:
131E            208            ;cpl SOUND_OUT ; Connect speaker to P3.7!
131E            209   no_beep:
131E 32         210            reti
131F            211            
131F            212   ;---------------------------------;
131F            213   ; Routine to initialize the ISR   ;
131F            214   ; for timer 1 in PWM mode         ;
131F            215   ;---------------------------------;
131F            216   
131F            217   Timer1_Init:
131F E589       218            mov a, TMOD
1321 540F       219            anl a, #00001111B       ;Clears timer 1 settings but keeps timer 0 settings
1323 4410       220            orl a, #00010000B       ;Gate = 0, TC1 = 0, mode = 01 (mode 1)
1325 F589       221            mov TMOD, a
1327            222            
1327 E591       223            mov a, TCONB            ;load TCONB for PWM settings
1329 5400       224            anl a, #00000000B       ;clear TCONB
132B 4480       225            orl a, #10000000B       ;Set PWM1 = 1
132D F591       226            mov TCONB, a
132F            227            
132F 758D00     228            mov TH1, #0             ;Current count value
1332 758B00     229            mov TL1, #0             ;Linear Prescaling
1335            230            
1335 75F500     231            mov TIMER1_RELOAD_H, #DUTY_0 ;Duty cycle percentage. Replace this value to change the duty cycle
1338 75F300     232            mov TIMER1_RELOAD_L, #0      ;Frequency scaling/adjust f_out = f_sys/(256 * (256 - TL))
133B            233            
133B D28E       234            setb TR1
133D 32         235            reti
133E            236   
133E            237   ;---------------------------------;
133E            238   ; Routine to initialize the ISR   ;
133E            239   ; for timer 2                     ;
133E            240   ;---------------------------------;
133E            241   Timer2_Init:
133E 75C800     242            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
1341 75CDA9     243            mov TH2, #high(TIMER2_RELOAD)
1344 75CC9A     244            mov TL2, #low(TIMER2_RELOAD)
1347            245            ; Set the reload value
1347 75CBA9     246            mov RCAP2H, #high(TIMER2_RELOAD)
134A 75CA9A     247            mov RCAP2L, #low(TIMER2_RELOAD)
134D            248            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
134D E4         249            clr a
134E F530       250            mov Count1ms+0, a
1350 F531       251            mov Count1ms+1, a
1352            252            ; Enable the timer and interrupts
1352 D2AD       253       setb ET2  ; Enable timer 2 interrupt
1354 D2CA       254       setb TR2  ; Enable timer 2
1356 22         255            ret
1357            256   
1357            257   ;---------------------------------;
1357            258   ; ISR for timer 2                 ;
1357            259   ;---------------------------------;
1357            260   Timer2_ISR:
1357 C2CF       261            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
1359            262            
1359            263            ; The two registers used in the ISR must be saved in the stack
1359 C0E0       264            push acc
135B C0D0       265            push psw
135D            266            
135D            267            ; Increment the 16-bit one mili second counter
135D            268                            ;       inc Count1ms+0    ; Increment the low 8-bits first
135D            269                                    ;mov a, Count1ms+0
135D            270                            ;       cjne a, #10h, Timer2_ISR_done
135D            271                            ;       mov Count1ms+0, #0h
135D 0530       272            inc Count1ms+0    ; Increment the low 8-bits first
135F E530       273            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
1361 7015       274            jnz Inc_Done
1363 0531       275            inc Count1ms+1
1365            276            
1365 C000       277            push ar0
1367 A841       277            mov r0, bcd
1369 120F77     277            lcall ?Send_BCD
136C 740D       277            mov a, #'\r'
136E 120D01     277       lcall putchar
1371 740A       277       mov a, #'\n'
1373 120D01     277       lcall putchar
1376 D000       277            pop ar0
1378            278            Inc_Done:
1378            279            ; Check if a second has passed
1378            280   
1378 E530       281            mov a, Count1ms+0
137A B4C815     282            cjne a, #low(MILLISECOND_WAIT), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
137D E531       283            mov a, Count1ms+1
137F B40010     284            cjne a, #high(MILLISECOND_WAIT), Timer2_ISR_done
1382            285            
1382            286            ; 1000 milliseconds have passed.  Set a flag so the main program knows
1382 D201       287            setb one_second_flag ; Let the main program know one second had passed
1384 B28C       288            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
1386            289            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
1386 E4         290            clr a
1387 F530       291            mov Count1ms+0, a
1389 F531       292            mov Count1ms+1, a
138B            293            ; Increment the BCD counter
138B E538       294            mov a, seconds
138D 2401       295            add a, #0x01
138F D4         296            da a ; Decimal adjust instruction.  Check datasheet for more details!
1390 F538       297            mov seconds, a
1392            298            
1392            299            
1392            300   Timer2_ISR_done:
1392            301            ;lcall seg_state_machine
1392            302   
1392 D0D0       303            pop psw
1394 D0E0       304            pop acc
1396 32         305            reti
1397            306   
1397            307   
1397            308   ;-------------------------------------
1397            309   ; To start or ABORT the reflow cycle
1397            310   ;------------------------------------
1397            311   Start_stop_Init: 
1397            312            
1397 759F01     313            mov KBMOD, #0x01        ; enable edge triggered for P0.0 and P0.1
139A 759C00     314            mov KBLS, #0x00         ; watch for negative edge (0->1)
139D 759D01     315            mov KBE, #0x01  ; enable interrupt for p0.0 and p0.1
13A0            316   ;        mov KBF, #0x01 ; interrupt active, must clear at start of ISR and setb at end. 
13A0            317   
13A0 22         318            ret
13A1            319   
13A1            320   Start_stop_ISR: 
13A1 759E00     321            mov KBF, #0             ; masks interrupt 
13A4 C0E0       322            push acc
13A6            323   
13A6 208512     324   jb MASTER_STOP, endhere_230
13A9 C002       324            push AR2
13AB 7A32       324            mov R2, #50
13AD 120254     324            lcall ?Wait_Milli_Seconds
13B0 D002       324            pop AR2
13B2 208506     324   jb MASTER_STOP, endhere_230
13B5 3085FD     324   jnb MASTER_STOP, $
13B8 0213F4     324   ljmp STOP_ROUTINE
13BB            324   
13BB            324   endhere_230:                             ; if master stop has been pressed, change to state 5
13BB 209012     325   jb MASTER_START, endhere_232
13BE C002       325            push AR2
13C0 7A32       325            mov R2, #50
13C2 120254     325            lcall ?Wait_Milli_Seconds
13C5 D002       325            pop AR2
13C7 209006     325   jb MASTER_START, endhere_232
13CA 3090FD     325   jnb MASTER_START, $
13CD 0213D0     325   ljmp START_ROUTINE
13D0            325   
13D0            325   endhere_232:                      ; if master start has been pressed, change to state 1
13D0            326   
13D0            327   START_ROUTINE: 
13D0            328            ; We should add some code here that 
13D0 E4         329            clr a
13D1 C0E0       330            push acc
13D3 7401       330            mov a, #1
13D5 14         330            dec a
13D6 1202DA     330            lcall ?Set_Cursor_2 ; Select column and row
13D9 D0E0       330            pop acc
13DB C083       331            push dph
13DD C082       331            push dpl
13DF C0E0       331            push acc
13E1 900228     331            mov dptr, #ISR_is_running
13E4 1202CF     331            lcall ?Send_Constant_String
13E7 D0E0       331            pop acc
13E9 D082       331            pop dpl
13EB D083       331            pop dph
13ED            331   
13ED E550       332            mov a, reflow_state
13EF            333            ;cjne a, #0x00, End_master_ISR
13EF 755001     334            mov reflow_state, #0x01
13F2 803D       335            sjmp End_master_ISR
13F4            336   
13F4            337   
13F4            338   
13F4            339   STOP_ROUTINE: 
13F4 755005     340            mov reflow_state, #5    
13F7            341            ; any other things we want to do, ie, statements we want to make 
13F7            342   
13F7 C0E0       343            push acc
13F9 7401       343            mov a, #1
13FB 14         343            dec a
13FC 1202DC     343            lcall ?Set_Cursor_1 ; Select column and row
13FF D0E0       343            pop acc
1401 C083       344            push dph
1403 C082       344            push dpl
1405 C0E0       344            push acc
1407 900206     344            mov dptr, #Abort_string
140A 1202CF     344            lcall ?Send_Constant_String
140D D0E0       344            pop acc
140F D082       344            pop dpl
1411 D083       344            pop dph
1413            345   
1413 C0E0       346            push acc
1415 7401       346            mov a, #1
1417 14         346            dec a
1418 1202DA     346            lcall ?Set_Cursor_2 ; Select column and row
141B D0E0       346            pop acc
141D C083       347            push dph
141F C082       347            push dpl
1421 C0E0       347            push acc
1423 900217     347            mov dptr, #Waiting_to_cool
1426 1202CF     347            lcall ?Send_Constant_String
1429 D0E0       347            pop acc
142B D082       347            pop dpl
142D D083       347            pop dph
142F            348   
142F 8000       349            sjmp End_master_ISR
1431            350   
1431            351   
1431            352   End_master_ISR: 
1431            353   ;        mov KBF, #1             ; enables interrupt
1431 D0E0       354            pop acc
1433            355   
1433 32         356            reti
1434            357   
1434            358   
1434            359   MainProgram:
1434 75817F     360       mov SP, #7FH ; Set the stack pointer to the begining of idata
1437 121397     361       lcall Start_stop_Init
143A 121303     362       lcall Timer0_Init
143D 12131F     363            lcall Timer1_Init
1440 12133E     364       lcall Timer2_Init
1443            365            ;lcall seg_state_init
1443 755000     366            mov reflow_state, #0x00
1446            367       ; In case you decide to use the pins of P0, configure the port in bidirectional mode:
1446 75E600     368       mov P0M0, #0
1449 75E700     369       mov P0M1, #0
144C            370            
144C 758E11     371            mov AUXR, #00010001B ; Max memory.  P4.4 is a general purpose IO pin
144F            372   
144F D2AF       373       setb EA   ; Enable Global interrupts
1451            374            
1451 120D14     375            lcall INIT_SPI
1454 1202A3     376       lcall LCD_4BIT
1457            377       
1457            378   menu_forever:
1457 020304     379       ljmp Main_Menu_Program
145A            380            
145A            381            
145A            382   forever:
145A 12106A     383            lcall GET_TEMP_DATA      ;This is the lab3 derivative loop that grabs the data from the thermocouple, 
145D 02107F     384            ljmp reflow_state_machine       ; go do some stuff in the state_machine
1460            385   
1460            386   
1460 02145A     387       ljmp forever ; This is equivalent to 'forever: sjmp forever'
1463            388   
1463            389       
1463            390   EN
