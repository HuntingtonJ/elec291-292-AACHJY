                 -1   $MODLP51
0000              1   ;--------------------------------------------------------
0000              2   ; Special Function Registers
0000              3   ;--------------------------------------------------------
0000              4   ACC            DATA 0xe0
0000              5   B              DATA 0xf0
0000              6   PSW            DATA 0xd0
0000              7   SP             DATA 0x81
0000              8   SPX            DATA 0xef
0000              9   DPL            DATA 0x82
0000             10   DPH            DATA 0x83
0000             11   DPLB           DATA 0xd4
0000             12   DPHB           DATA 0xd5
0000             13   PAGE           DATA 0xf6
0000             14   AX             DATA 0xe1
0000             15   BX             DATA 0xf7
0000             16   DSPR           DATA 0xe2
0000             17   FIRD           DATA 0xe3
0000             18   MACL           DATA 0xe4
0000             19   MACH           DATA 0xe5
0000             20   PCON           DATA 0x87
0000             21   AUXR           DATA 0x8e
0000             22   AUXR1          DATA 0xa2
0000             23   DPCF           DATA 0xa1
0000             24   CKRL           DATA 0x97
0000             25   CKCKON0        DATA 0x8f
0000             26   CKCKON1        DATA 0xaf
0000             27   CKSEL          DATA 0x85
0000             28   CLKREG         DATA 0xae
0000             29   OSCCON         DATA 0x85
0000             30   IE             DATA 0xa8
0000             31   IEN0           DATA 0xa8
0000             32   IEN1           DATA 0xb1
0000             33   IPH0           DATA 0xb7
0000             34   IP             DATA 0xb8
0000             35   IPL0           DATA 0xb8
0000             36   IPH1           DATA 0xb3
0000             37   IPL1           DATA 0xb2
0000             38   P0             DATA 0x80
0000             39   P1             DATA 0x90
0000             40   P2             DATA 0xa0
0000             41   P3             DATA 0xb0
0000             42   P4             DATA 0xc0
0000             43   P0M0           DATA 0xe6
0000             44   P0M1           DATA 0xe7
0000             45   P1M0           DATA 0xd6
0000             46   P1M1           DATA 0xd7
0000             47   P2M0           DATA 0xce
0000             48   P2M1           DATA 0xcf
0000             49   P3M0           DATA 0xc6
0000             50   P3M1           DATA 0xc7
0000             51   P4M0           DATA 0xbe
0000             52   P4M1           DATA 0xbf
0000             53   SCON           DATA 0x98
0000             54   SBUF           DATA 0x99
0000             55   SADEN          DATA 0xb9
0000             56   SADDR          DATA 0xa9
0000             57   BDRCON         DATA 0x9b
0000             58   BRL            DATA 0x9a
0000             59   TCON           DATA 0x88
0000             60   TMOD           DATA 0x89
0000             61   TCONB          DATA 0x91
0000             62   TL0            DATA 0x8a
0000             63   TH0            DATA 0x8c
0000             64   TL1            DATA 0x8b
0000             65   TH1            DATA 0x8d
0000             66   RL0            DATA 0xf2
0000             67   RL1            DATA 0xf3
0000             68   RH0            DATA 0xf4
0000             69   RH1            DATA 0xf5
0000             70   WDTRST         DATA 0xa6
0000             71   WDTPRG         DATA 0xa7
0000             72   T2CON          DATA 0xc8
0000             73   T2MOD          DATA 0xc9
0000             74   RCAP2H         DATA 0xcb
0000             75   RCAP2L         DATA 0xca
0000             76   TH2            DATA 0xcd
0000             77   TL2            DATA 0xcc
0000             78   SPCON          DATA 0xc3
0000             79   SPSTA          DATA 0xc4
0000             80   SPDAT          DATA 0xc5
0000             81   SSCON          DATA 0x93
0000             82   SSCS           DATA 0x94
0000             83   SSDAT          DATA 0x95
0000             84   SSADR          DATA 0x96
0000             85   KBLS           DATA 0x9c
0000             86   KBE            DATA 0x9d
0000             87   KBF            DATA 0x9e
0000             88   KBMOD          DATA 0x9f
0000             89   BMSEL          DATA 0x92
0000             90   FCON           DATA 0xd2
0000             91   EECON          DATA 0xd2
0000             92   ACSRA          DATA 0xa3
0000             93   ACSRB          DATA 0xab
0000             94   AREF           DATA 0xbd
0000             95   DADC           DATA 0xa4
0000             96   DADI           DATA 0xa5
0000             97   DADL           DATA 0xac
0000             98   DADH           DATA 0xad
0000             99   CCON           DATA 0xd8
0000            100   CMOD           DATA 0xd9
0000            101   CL             DATA 0xe9
0000            102   CH             DATA 0xf9
0000            103   CCAPM0         DATA 0xda
0000            104   CCAPM1         DATA 0xdb
0000            105   CCAPM2         DATA 0xdc
0000            106   CCAPM3         DATA 0xdd
0000            107   CCAPM4         DATA 0xde
0000            108   CCAP0H         DATA 0xfa
0000            109   CCAP1H         DATA 0xfb
0000            110   CCAP2H         DATA 0xfc
0000            111   CCAP3H         DATA 0xfd
0000            112   CCAP4H         DATA 0xfe
0000            113   CCAP0L         DATA 0xea
0000            114   CCAP1L         DATA 0xeb
0000            115   CCAP2L         DATA 0xec
0000            116   CCAP3L         DATA 0xed
0000            117   CCAP4L         DATA 0xee
0000            118   ;--------------------------------------------------------
0000            119   ; special function bits
0000            120   ;--------------------------------------------------------
0000            121   P              BIT 0xd0
0000            122   F1             BIT 0xd1
0000            123   OV             BIT 0xd2
0000            124   RS0            BIT 0xd3
0000            125   RS1            BIT 0xd4
0000            126   F0             BIT 0xd5
0000            127   AC             BIT 0xd6
0000            128   CY             BIT 0xd7
0000            129   EX0            BIT 0xa8
0000            130   ET0            BIT 0xa9
0000            131   EX1            BIT 0xaa
0000            132   ET1            BIT 0xab
0000            133   ES             BIT 0xac
0000            134   ET2            BIT 0xad
0000            135   EC             BIT 0xae
0000            136   EA             BIT 0xaf
0000            137   PX0            BIT 0xb8
0000            138   PT0            BIT 0xb9
0000            139   PX1            BIT 0xba
0000            140   PT1            BIT 0xbb
0000            141   PS             BIT 0xbc
0000            142   PT2            BIT 0xbd
0000            143   IP0D           BIT 0xbf
0000            144   PPCL           BIT 0xbe
0000            145   PT2L           BIT 0xbd
0000            146   PLS            BIT 0xbc
0000            147   PT1L           BIT 0xbb
0000            148   PX1L           BIT 0xba
0000            149   PT0L           BIT 0xb9
0000            150   PX0L           BIT 0xb8
0000            151   RXD            BIT 0xb0
0000            152   TXD            BIT 0xb1
0000            153   INT0           BIT 0xb2
0000            154   INT1           BIT 0xb3
0000            155   T0             BIT 0xb4
0000            156   T1             BIT 0xb5
0000            157   WR             BIT 0xb6
0000            158   RD             BIT 0xb7
0000            159   RI             BIT 0x98
0000            160   TI             BIT 0x99
0000            161   RB8            BIT 0x9a
0000            162   TB8            BIT 0x9b
0000            163   REN            BIT 0x9c
0000            164   SM2            BIT 0x9d
0000            165   SM1            BIT 0x9e
0000            166   SM0            BIT 0x9f
0000            167   IT0            BIT 0x88
0000            168   IE0            BIT 0x89
0000            169   IT1            BIT 0x8a
0000            170   IE1            BIT 0x8b
0000            171   TR0            BIT 0x8c
0000            172   TF0            BIT 0x8d
0000            173   TR1            BIT 0x8e
0000            174   TF1            BIT 0x8f
0000            175   CP_RL2         BIT 0xc8
0000            176   C_T2           BIT 0xc9
0000            177   TR2            BIT 0xca
0000            178   EXEN2          BIT 0xcb
0000            179   TCLK           BIT 0xcc
0000            180   RCLK           BIT 0xcd
0000            181   EXF2           BIT 0xce
0000            182   TF2            BIT 0xcf
0000            183   CF             BIT 0xdf
0000            184   CR             BIT 0xde
0000            185   CCF4           BIT 0xdc
0000            186   CCF3           BIT 0xdb
0000            187   CCF2           BIT 0xda
0000            188   CCF1           BIT 0xd9
0000            189   CCF0           BIT 0xd8
0000              2   
0000              3   ; There is a couple of typos in MODLP51 in the definition of the timer 0/1 reload
0000              4   ; special function registers (SFRs), so:
0000              5   
0000              6   TIMER0_RELOAD_L DATA 0xf2
0000              7   TIMER1_RELOAD_L DATA 0xf3
0000              8   TIMER0_RELOAD_H DATA 0xf4
0000              9   TIMER1_RELOAD_H DATA 0xf5
0000             10   
0000             11   CLK              EQU 22118400 ; Microcontroller system crystal frequency in Hz
0000             12   TIMER0_RATE      EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             13   TIMER0_RELOAD    EQU ((65536-(CLK/TIMER0_RATE)))
0000             14   TIMER2_RATE      EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             15   TIMER2_RELOAD    EQU ((65536-(CLK/TIMER2_RATE)))
0000             16   MAX_TEMP              EQU 250
0000             17   TIMEOUT_TIME     EQU 60
0000             18   BAUD             EQU 115200
0000             19   BRG_VAL          EQU (0x100-(CLK/(16*BAUD)))
0000             20   MILLISECOND_WAIT EQU 200                 ; how many milliseconds between temp samples
0000             21   
0000             22   DUTY_0           EQU 0
0000             23   DUTY_20          EQU 51   ;256 * 0.2
0000             24   DUTY_50          EQU 128  ;256 * 0.5
0000             25   DUTY_80          EQU 204  ;256 * 0.8
0000             26   DUTY_100         EQU 255
0000             27   
0000             28   org 0x0000
0000 021C72      29      ljmp MainProgram
0003             30   
0003             31   ; External interrupt 0 vector (not used in this code)
0003             32   org 0x0003
0003 32          33            reti
0004             34   
0004             35   ; Timer/Counter 0 overflow interrupt vector
000B             36   org 0x000B
000B 0219FD      37            ljmp Timer0_ISR
000E             38   
000E             39   ; External interrupt 1 vector (not used in this code)
0013             40   org 0x0013
0013 32          41            reti
0014             42   
0014             43   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             44   org 0x001B
001B 32          45            reti
001C             46   
001C             47   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             48   org 0x0023 
0023 32          49            reti
0024             50            
0024             51   ; Timer/Counter 2 overflow interrupt vector
002B             52   org 0x002B
002B 021A38      53            ljmp Timer2_ISR
002E             54   
002E             55   ;Edge triggered keyboard interrupt vector
003B             56   org 0x003B
003B 021A87      57            ljmp Start_stop_ISR
003E             58   
003E             59   ; These ’EQU’ must match the wiring between the microcontroller and ADC
003E             60   SOUND_OUT     EQU P3.7
003E             61   CE_ADC        EQU P2.0
003E             62   MY_MOSI       EQU P2.1
003E             63   MY_MISO       EQU P2.2
003E             64   MY_SCLK       EQU P2.3
003E             65   
003E             66   UP_BUTTON          EQU P2.6 
003E             67   DOWN_BUTTON   EQU P2.5
003E             68   SELECT_BUTTON equ P2.4
003E             69   BACK_BUTTON   EQU #11110000B
003E             70   MASTER_START  EQU #10100000B 
003E             71   MASTER_STOP   EQU #10110000B
003E             72   
003E             73   ; For the 7-segment display
003E             74   SEGA equ P0.3
003E             75   SEGB equ P0.5
003E             76   SEGC equ P0.7
003E             77   SEGD equ P4.4
003E             78   SEGE equ P4.5
003E             79   SEGF equ P0.4
003E             80   SEGG equ P0.6
003E             81   SEGP equ P2.7
003E             82   CA1  equ P0.1
003E             83   CA2  equ P0.0
003E             84   CA3  equ P0.2
003E             85   
003E             86   ; For the LCD
003E             87   LCD_RS equ P1.1
003E             88   LCD_RW equ P1.2
003E             89   LCD_E  equ P1.3
003E             90   LCD_D4 equ P3.2
003E             91   LCD_D5 equ P3.3
003E             92   LCD_D6 equ P3.4
003E             93   LCD_D7 equ P3.6
003E             94   
003E             95   ; pins to be used on the MPC 3008
003E             96   adc_zero                 equ #10000000B               ; LM355 temp sensor 
003E             97   adc_one                  equ #10010000B               ; thermocouple
003E             98   adc_two                  equ #10100000B               ;  start
003E             99   adc_three                equ #10110000B               ;  stop
003E            100   adc_four                 equ #11000000B               ;  
003E            101   adc_five                 equ #11010000B               ;  
003E            102   adc_six                  equ #11100000B               ; 
003E            103   adc_seven                equ #11110000B                           ; back
003E            104   
0030            105   DSEG at 0x30
0030            106   Count1ms:       ds 2 ; Used to determine when half second has passed
0032            107   Result:         ds 2 ; Temp from lm355
0034            108   Result_Thermo:  ds 2 ; Temp from Thermocoupler
0036            109   ADC_Result:     ds 2 ; Temp from ADC channel 2
0038            110   
0038            111   BCD_temp:       ds 2 ; Used to diplay temp on the 7-segment display
003A            112   seconds:        ds 1
003B            113   x:              ds 4 ; Used in math32
003F            114   y:              ds 4 ; Used in math32
0043            115   bcd:            ds 5
0048            116   soaktime:       ds 2
004A            117   soaktemp:       ds 2
004C            118   reflowtime:     ds 2
004E            119   reflowtemp:     ds 2
0050            120   soaktemp3digit: ds 2
0052            121   reflow_state:   ds 1
0053            122   pwm:            ds 1
0054            123   temp:           ds 1
0055            124   sec:            ds 1 ; seconds variable for reflow FSM (to be incremented every second)
0056            125   cooled_temp:    ds 1
0057            126   ; 7-segment vars
0057            127   Disp1:          ds 1 ; Least significant digit
0058            128   Disp2:          ds 1
0059            129   Disp3:          ds 1 ; Most significant digit
005A            130   seg_state:      ds 1 ; state of 7_seg fsm
005B            131   
005B            132   
005B            133   
0000            134   BSEG
0000            135   mf: dbit 1
0001            136   one_second_flag: dbit 1 
0002            137   shortbeepflag: dbit 1
0003            138   longbeepflag: dbit 1
0004            139   sixbeepflag: dbit 1
0005            140   
0005            141   
003E            142   CSEG
003E            143                    ;                        1234567890123456
003E 20202020   144   Ramp_to_Soak:    db       '         Preheat', 0
     20202020
     20507265
     68656174
     00
004F 20202020   145   Soak:                    db   '         Soak   ', 0
     20202020
     20536F61
     6B202020
     00
0060 20202020   146   Ramp_to_Peak:    db       '         Ramp2pk', 0
     20202020
     2052616D
     7032706B
     00
0071 20202020   147   Reflow:                  db       '         Reflow ', 0
     20202020
     20526566
     6C6F7720
     00
0082 20202020   148   Cooling:                 db       '         Cooling', 0
     20202020
     20436F6F
     6C696E67
     00
0093 7300       149   secondsss:               db   's'                , 0
0095            150   ;                     1234567890123456    <- This helps determine the location of the counter
0095 57656C63   151   Welcome:                   db 'Welcome!        ', 0
     6F6D6521
     20202020
     20202020
     00
00A6 53656C65   152   Choose_option:     db 'Select option   ', 0
     6374206F
     7074696F
     6E202020
     00
00B7 50726573   153   Preset_menu_msg:  db 'Preset Profile  ', 0
     65742050
     726F6669
     6C652020
     00
00C8 43757374   154   Custom_menu_msg:  db 'Custom Profile  ', 0
     6F6D2050
     726F6669
     6C652020
     00
00D9 536F616B   155   Soak_temp:                 db 'Soak Temp       ', 0
     2054656D
     70202020
     20202020
     00
00EA 536F616B   156   Soak_time:                 db 'Soak Time       ', 0
     2054696D
     65202020
     20202020
     00
00FB 5265666C   157   Reflow_time:       db 'Reflow Time     ', 0
     6F772054
     696D6520
     20202020
     00
010C 5265666C   158   Reflow_temp:       db 'Reflow Temp     ', 0
     6F772054
     656D7020
     20202020
     00
011D 53414333   159   Pb_free_solder:    db 'SAC305 solder   ', 0
     30352073
     6F6C6465
     72202020
     00
012E 50622D73   160   Pb_solder:                 db 'Pb-solder paste ', 0
     6F6C6465
     72207061
     73746520
     00
013F 53686868   161   Pizza_msg0:        db 'Shhh! No pizza  ', 0
     21204E6F
     2070697A
     7A612020
     00
0150 616C6C6F   162   Pizza_msg1:        db 'allowed in here.', 0
     77656420
     696E2068
     6572652E
     00
0161 70726F66   163   Profile_loaded:   db 'profile loaded  ', 0
     696C6520
     6C6F6164
     65642020
     00
0172 53797374   164   Is_ready:                  db 'System Ready    ', 0
     656D2052
     65616479
     20202020
     00
0183 50726573   165   Press_start:       db 'Press Start     ', 0
     73205374
     61727420
     20202020
     00
0194 78782020   166   Set_Value:                 db 'xx              ', 0
     20202020
     20202020
     20202020
     00
01A5 20202020   167   Clear_Row:                 db '                ', 0
     20202020
     20202020
     20202020
     00
01B6 41542050   168   PRESETMENUMSG:     db 'AT PRESET MENU  ', 0
     52455345
     54204D45
     4E552020
     00
01C7 41542043   169   CUSTOMMENUMSG:     db 'AT CUSTOM MENU  ', 0
     5553544F
     4D204D45
     4E552020
     00
01D8 41726520   170   Are_you_sure:      db 'Are you sure?   ', 0
     796F7520
     73757265
     3F202020
     00
01E9 4572726F   171   Error_msg1:        db 'Error, profiles ', 0
     722C2070
     726F6669
     6C657320
     00
01FA 6E6F7420   172   Error_msg2:       db 'not loaded      ', 0
     6C6F6164
     65642020
     20202020
     00
020B 50726F63   173   Abort_string:      db 'Process aborted ', 0
     65737320
     61626F72
     74656420
     00
021C 57616974   174   Waiting_to_cool:  db 'Wait to cool    ', 0
     20746F20
     636F6F6C
     20202020
     00
022D 49535220   175   ISR_is_running:   db 'ISR is running  ', 0
     69732072
     756E6E69
     6E672020
     00
023E            176   
023E 53746174   177   State_0: db 'State 0', 0
     65203000
0246 53746174   178   State_1: db 'State 1', 0
     65203100
024E            179   
024E            180   
                182   	$LIST
02FC            184   
                546   $LIST
                186   $LIST
056C            188   
                190   $LIST
12E7            192   
                194   $LIST
16D3            196   
                198   $LIST
195E            200   
195E            201   
                203   $LIST
19E4            205   
19E4            206   ;----------------------------------------MACRO LOCATION----------------------------------------------
19E4            207   
19E4            208   
19E4            209   
19E4            210   
19E4            211   ;---------------------------------;
19E4            212   ; Routine to initialize the ISR   ;
19E4            213   ; for timer 0                     ;
19E4            214   ;---------------------------------;
19E4            215   Timer0_Init:
19E4 E589       216            mov a, TMOD
19E6 54F0       217            anl a, #0xf0 ; Clear the bits for timer 0
19E8 4401       218            orl a, #0x01 ; Configure timer 0 as 16-timer
19EA F589       219            mov TMOD, a
19EC 758CEA     220            mov TH0, #high(TIMER0_RELOAD)
19EF 758AE8     221            mov TL0, #low(TIMER0_RELOAD)
19F2            222            ; Set autoreload value
19F2 75F4EA     223            mov TIMER0_RELOAD_H, #high(TIMER0_RELOAD)
19F5 75F2E8     224            mov TIMER0_RELOAD_L, #low(TIMER0_RELOAD)
19F8            225            ; Enable the timer and interrupts
19F8 D2A9       226       setb ET0  ; Enable timer 0 interrupt
19FA D28C       227       setb TR0  ; Start timer 0
19FC 22         228            ret
19FD            229   
19FD            230   ;---------------------------------;
19FD            231   ; ISR for timer 0.  Set to execute;
19FD            232   ; every 1/4096Hz to generate a    ;
19FD            233   ; 2048 Hz square wave at pin P3.7 ;
19FD            234   ;---------------------------------;
19FD            235   Timer0_ISR:
19FD            236            ;clr TF0  ; According to the data sheet this is done for us already.
19FD 8000       237            sjmp no_beep
19FF            238   beep_on:
19FF            239            ;cpl SOUND_OUT ; Connect speaker to P3.7!
19FF            240   no_beep:
19FF 32         241            reti
1A00            242            
1A00            243   ;---------------------------------;
1A00            244   ; Routine to initialize the ISR   ;
1A00            245   ; for timer 1 in PWM mode         ;
1A00            246   ;---------------------------------;
1A00            247   
1A00            248   Timer1_Init:
1A00 E589       249            mov a, TMOD
1A02 540F       250            anl a, #00001111B       ;Clears timer 1 settings but keeps timer 0 settings
1A04 4410       251            orl a, #00010000B       ;Gate = 0, TC1 = 0, mode = 01 (mode 1)
1A06 F589       252            mov TMOD, a
1A08            253            
1A08 E591       254            mov a, TCONB            ;load TCONB for PWM settings
1A0A 5400       255            anl a, #00000000B       ;clear TCONB
1A0C 4480       256            orl a, #10000000B       ;Set PWM1 = 1
1A0E F591       257            mov TCONB, a
1A10            258            
1A10 758D00     259            mov TH1, #0             ;Current count value
1A13 758B00     260            mov TL1, #0             ;Linear Prescaling
1A16            261            
1A16 75F500     262            mov TIMER1_RELOAD_H, #DUTY_0 ;Duty cycle percentage. Replace this value to change the duty cycle
1A19 75F300     263            mov TIMER1_RELOAD_L, #0      ;Frequency scaling/adjust f_out = f_sys/(256 * (256 - TL))
1A1C            264            
1A1C D28E       265            setb TR1
1A1E 32         266            reti
1A1F            267   
1A1F            268   ;---------------------------------;
1A1F            269   ; Routine to initialize the ISR   ;
1A1F            270   ; for timer 2                     ;
1A1F            271   ;---------------------------------;
1A1F            272   Timer2_Init:
1A1F 75C800     273            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
1A22 75CDA9     274            mov TH2, #high(TIMER2_RELOAD)
1A25 75CC9A     275            mov TL2, #low(TIMER2_RELOAD)
1A28            276            ; Set the reload value
1A28 75CBA9     277            mov RCAP2H, #high(TIMER2_RELOAD)
1A2B 75CA9A     278            mov RCAP2L, #low(TIMER2_RELOAD)
1A2E            279            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
1A2E E4         280            clr a
1A2F F530       281            mov Count1ms+0, a
1A31 F531       282            mov Count1ms+1, a
1A33            283            ; Enable the timer and interrupts
1A33 D2AD       284       setb ET2  ; Enable timer 2 interrupt
1A35 D2CA       285       setb TR2  ; Enable timer 2
1A37 22         286            ret
1A38            287   
1A38            288   ;---------------------------------;
1A38            289   ; ISR for timer 2                 ;
1A38            290   ;---------------------------------;
1A38            291   Timer2_ISR:
1A38 C2CF       292            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
1A3A B290       293            cpl p1.0
1A3C            294            ; The two registers used in the ISR must be saved in the stack
1A3C C0E0       295            push acc
1A3E C0D0       296            push psw
1A40 121989     297            lcall seg_state_machine
1A43            298            ; Increment the 16-bit one mili second counter
1A43            299                            ;       inc Count1ms+0    ; Increment the low 8-bits first
1A43            300                                    ;mov a, Count1ms+0
1A43            301                            ;       cjne a, #10h, Timer2_ISR_done
1A43            302                            ;       mov Count1ms+0, #0h
1A43 0530       303            inc Count1ms+0    ; Increment the low 8-bits first
1A45 E530       304            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
1A47 7015       305            jnz Inc_Done
1A49 0531       306            inc Count1ms+1
1A4B            307            
1A4B C000       308            push ar0
1A4D A843       308            mov r0, bcd
1A4F 121575     308            lcall ?Send_BCD
1A52 740D       308            mov a, #'\r'
1A54 1212FF     308       lcall putchar
1A57 740A       308       mov a, #'\n'
1A59 1212FF     308       lcall putchar
1A5C D000       308            pop ar0
1A5E            309            Inc_Done:
1A5E            310            ; Check if a second has passed
1A5E            311   
1A5E E530       312            mov a, Count1ms+0
1A60 B4C815     313            cjne a, #low(MILLISECOND_WAIT), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
1A63 E531       314            mov a, Count1ms+1
1A65 B40010     315            cjne a, #high(MILLISECOND_WAIT), Timer2_ISR_done
1A68            316            
1A68            317            ; 1000 milliseconds have passed.  Set a flag so the main program knows
1A68 D201       318            setb one_second_flag ; Let the main program know one second had passed
1A6A B28C       319            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
1A6C            320            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
1A6C E4         321            clr a
1A6D F530       322            mov Count1ms+0, a
1A6F F531       323            mov Count1ms+1, a
1A71            324            ; Increment the BCD counter
1A71 E53A       325            mov a, seconds
1A73 2401       326            add a, #0x01
1A75 D4         327            da a ; Decimal adjust instruction.  Check datasheet for more details!
1A76 F53A       328            mov seconds, a
1A78            329            
1A78            330   Timer2_ISR_done:
1A78 D0D0       331            pop psw
1A7A D0E0       332            pop acc
1A7C 32         333            reti
1A7D            334   
1A7D            335   
1A7D            336   ;-------------------------------------
1A7D            337   ; To start or ABORT the reflow cycle
1A7D            338   ;------------------------------------
1A7D            339   Start_stop_Init: 
1A7D            340            
1A7D 759F01     341            mov KBMOD, #0x01        ; enable edge triggered for P0.0 and P0.1
1A80 759C00     342            mov KBLS, #0x00         ; watch for negative edge (0->1)
1A83 759D01     343            mov KBE, #0x01  ; enable interrupt for p0.0 and p0.1
1A86            344   ;        mov KBF, #0x01 ; interrupt active, must clear at start of ISR and setb at end. 
1A86            345   
1A86 22         346            ret
1A87            347   
1A87            348   Start_stop_ISR: 
1A87 759E00     349            mov KBF, #0             ; masks interrupt 
1A8A C0E0       350            push acc
1A8C            351   
1A8C C2A0       352            clr CE_ADC         ; selects 
1A8E 7801       352       mov R0, #00000001B ; Start bit: 1
1A90 121317     352       lcall DO_SPI_G
1A93            352       
1A93 78B0       352       mov R0, MASTER_STOP ; Read channel
1A95 121317     352       lcall DO_SPI_G
1A98 E9         352       mov a, R1
1A99 5403       352       anl a, #00000011B
1A9B F537       352       mov ADC_Result+1, a    ; Save high result
1A9D            352       
1A9D 7855       352       mov R0, #55H
1A9F 121317     352       lcall DO_SPI_G
1AA2 8936       352       mov ADC_Result+0, R1     ; Save low result
1AA4            352       
1AA4 D2A0       352       setb CE_ADC        ; deselects
1AA6            352       
1AA6            352       ;V_OUT = ADC_voltage*4.096V/1023
1AA6 85363B     352       mov x+0, ADC_Result
1AA9 85373C     352       mov x+1, ADC_Result+1
1AAC 753D00     352       mov x+2, #0
1AAF 753E00     352       mov x+3, #0
1AB2            352       
1AB2 753FFB     352            mov y+0, #low (4091 % 0x10000) 
1AB5 75400F     352            mov y+1, #high(4091 % 0x10000) 
1AB8 754100     352            mov y+2, #low (4091 / 0x10000) 
1ABB 754200     352            mov y+3, #high(4091 / 0x10000) 
1ABE 120476     352       lcall mul32 ;multiplies x *= y
1AC1            352       
1AC1 753FFF     352            mov y+0, #low (1023 % 0x10000) 
1AC4 754003     352            mov y+1, #high(1023 % 0x10000) 
1AC7 754100     352            mov y+2, #low (1023 / 0x10000) 
1ACA 754200     352            mov y+3, #high(1023 / 0x10000) 
1ACD 120503     352       lcall div32 ;divides x /= y
1AD0            352       
1AD0 753FE8     352            mov y+0, #low (1000 % 0x10000) 
1AD3 754003     352            mov y+1, #high(1000 % 0x10000) 
1AD6 754100     352            mov y+2, #low (1000 / 0x10000) 
1AD9 754200     352            mov y+3, #high(1000 / 0x10000) 
1ADC 120503     352       lcall div32
1ADF            352       
1ADF 853C37     352       mov ADC_Result+1, x+1
1AE2 853B36     352       mov ADC_Result+0, x+0
1AE5            352            ; loads ADC_Result (16 bit) with voltage value of pressed button 
1AE5 E536       352            mov a, ADC_Result+0
1AE7 B40002     352            cjne a, #0, wait_release_292
1AEA            352   
1AEA 8061       352            sjmp endhere_292
1AEC            352   wait_release_292:
1AEC C2A0       352            clr CE_ADC         ; selects 
1AEE 7801       352       mov R0, #00000001B ; Start bit: 1
1AF0 121317     352       lcall DO_SPI_G
1AF3            352       
1AF3 78B0       352       mov R0, MASTER_STOP ; Read channel
1AF5 121317     352       lcall DO_SPI_G
1AF8 E9         352       mov a, R1
1AF9 5403       352       anl a, #00000011B
1AFB F537       352       mov ADC_Result+1, a    ; Save high result
1AFD            352       
1AFD 7855       352       mov R0, #55H
1AFF 121317     352       lcall DO_SPI_G
1B02 8936       352       mov ADC_Result+0, R1     ; Save low result
1B04            352       
1B04 D2A0       352       setb CE_ADC        ; deselects
1B06            352       
1B06            352       ;V_OUT = ADC_voltage*4.096V/1023
1B06 85363B     352       mov x+0, ADC_Result
1B09 85373C     352       mov x+1, ADC_Result+1
1B0C 753D00     352       mov x+2, #0
1B0F 753E00     352       mov x+3, #0
1B12            352       
1B12 753FFB     352            mov y+0, #low (4091 % 0x10000) 
1B15 75400F     352            mov y+1, #high(4091 % 0x10000) 
1B18 754100     352            mov y+2, #low (4091 / 0x10000) 
1B1B 754200     352            mov y+3, #high(4091 / 0x10000) 
1B1E 120476     352       lcall mul32 ;multiplies x *= y
1B21            352       
1B21 753FFF     352            mov y+0, #low (1023 % 0x10000) 
1B24 754003     352            mov y+1, #high(1023 % 0x10000) 
1B27 754100     352            mov y+2, #low (1023 / 0x10000) 
1B2A 754200     352            mov y+3, #high(1023 / 0x10000) 
1B2D 120503     352       lcall div32 ;divides x /= y
1B30            352       
1B30 753FE8     352            mov y+0, #low (1000 % 0x10000) 
1B33 754003     352            mov y+1, #high(1000 % 0x10000) 
1B36 754100     352            mov y+2, #low (1000 / 0x10000) 
1B39 754200     352            mov y+3, #high(1000 / 0x10000) 
1B3C 120503     352       lcall div32
1B3F            352       
1B3F 853C37     352       mov ADC_Result+1, x+1
1B42 853B36     352       mov ADC_Result+0, x+0
1B45            352            ; loads ADC_Result (16 bit) with voltage value of pressed button 
1B45 E536       352            mov a, ADC_Result+0
1B47 B400A2     352            cjne a, #0,wait_release_292
1B4A 021C32     352            ljmp STOP_ROUTINE
1B4D            352            endhere_292:    ; if master stop has been pressed, change to state 5
1B4D C2A0       353            clr CE_ADC         ; selects 
1B4F 7801       353       mov R0, #00000001B ; Start bit: 1
1B51 121317     353       lcall DO_SPI_G
1B54            353       
1B54 78A0       353       mov R0, MASTER_START ; Read channel
1B56 121317     353       lcall DO_SPI_G
1B59 E9         353       mov a, R1
1B5A 5403       353       anl a, #00000011B
1B5C F537       353       mov ADC_Result+1, a    ; Save high result
1B5E            353       
1B5E 7855       353       mov R0, #55H
1B60 121317     353       lcall DO_SPI_G
1B63 8936       353       mov ADC_Result+0, R1     ; Save low result
1B65            353       
1B65 D2A0       353       setb CE_ADC        ; deselects
1B67            353       
1B67            353       ;V_OUT = ADC_voltage*4.096V/1023
1B67 85363B     353       mov x+0, ADC_Result
1B6A 85373C     353       mov x+1, ADC_Result+1
1B6D 753D00     353       mov x+2, #0
1B70 753E00     353       mov x+3, #0
1B73            353       
1B73 753FFB     353            mov y+0, #low (4091 % 0x10000) 
1B76 75400F     353            mov y+1, #high(4091 % 0x10000) 
1B79 754100     353            mov y+2, #low (4091 / 0x10000) 
1B7C 754200     353            mov y+3, #high(4091 / 0x10000) 
1B7F            353   
1B7F 120476     353       lcall mul32 ;multiplies x *= y
1B82            353       
1B82 753FFF     353            mov y+0, #low (1023 % 0x10000) 
1B85 754003     353            mov y+1, #high(1023 % 0x10000) 
1B88 754100     353            mov y+2, #low (1023 / 0x10000) 
1B8B 754200     353            mov y+3, #high(1023 / 0x10000) 
1B8E 120503     353       lcall div32 ;divides x /= y
1B91            353       
1B91 753FE8     353            mov y+0, #low (1000 % 0x10000) 
1B94 754003     353            mov y+1, #high(1000 % 0x10000) 
1B97 754100     353            mov y+2, #low (1000 / 0x10000) 
1B9A 754200     353            mov y+3, #high(1000 / 0x10000) 
1B9D 120503     353       lcall div32
1BA0            353       
1BA0 853C37     353       mov ADC_Result+1, x+1
1BA3 853B36     353       mov ADC_Result+0, x+0
1BA6            353            ; loads ADC_Result (16 bit) with voltage value of pressed button 
1BA6 E536       353            mov a, ADC_Result+0
1BA8 B40002     353            cjne a, #0, wait_release_301
1BAB            353   
1BAB 8061       353            sjmp endhere_301
1BAD            353   wait_release_301:
1BAD C2A0       353            clr CE_ADC         ; selects 
1BAF 7801       353       mov R0, #00000001B ; Start bit: 1
1BB1 121317     353       lcall DO_SPI_G
1BB4            353       
1BB4 78A0       353       mov R0, MASTER_START ; Read channel
1BB6 121317     353       lcall DO_SPI_G
1BB9 E9         353       mov a, R1
1BBA 5403       353       anl a, #00000011B
1BBC F537       353       mov ADC_Result+1, a    ; Save high result
1BBE            353       
1BBE 7855       353       mov R0, #55H
1BC0 121317     353       lcall DO_SPI_G
1BC3 8936       353       mov ADC_Result+0, R1     ; Save low result
1BC5            353       
1BC5 D2A0       353       setb CE_ADC        ; deselects
1BC7            353       
1BC7            353       ;V_OUT = ADC_voltage*4.096V/1023
1BC7 85363B     353       mov x+0, ADC_Result
1BCA 85373C     353       mov x+1, ADC_Result+1
1BCD 753D00     353       mov x+2, #0
1BD0 753E00     353       mov x+3, #0
1BD3            353       
1BD3 753FFB     353            mov y+0, #low (4091 % 0x10000) 
1BD6 75400F     353            mov y+1, #high(4091 % 0x10000) 
1BD9 754100     353            mov y+2, #low (4091 / 0x10000) 
1BDC 754200     353            mov y+3, #high(4091 / 0x10000) 
1BDF            353   
1BDF 120476     353       lcall mul32 ;multiplies x *= y
1BE2            353       
1BE2 753FFF     353            mov y+0, #low (1023 % 0x10000) 
1BE5 754003     353            mov y+1, #high(1023 % 0x10000) 
1BE8 754100     353            mov y+2, #low (1023 / 0x10000) 
1BEB 754200     353            mov y+3, #high(1023 / 0x10000) 
1BEE 120503     353       lcall div32 ;divides x /= y
1BF1            353       
1BF1 753FE8     353            mov y+0, #low (1000 % 0x10000) 
1BF4 754003     353            mov y+1, #high(1000 % 0x10000) 
1BF7 754100     353            mov y+2, #low (1000 / 0x10000) 
1BFA 754200     353            mov y+3, #high(1000 / 0x10000) 
1BFD 120503     353       lcall div32
1C00            353       
1C00 853C37     353       mov ADC_Result+1, x+1
1C03 853B36     353       mov ADC_Result+0, x+0
1C06            353            ; loads ADC_Result (16 bit) with voltage value of pressed button 
1C06 E536       353            mov a, ADC_Result+0
1C08 B400A2     353            cjne a, #0,wait_release_301
1C0B 021C0E     353            ljmp START_ROUTINE
1C0E            353            endhere_301: ; if master start has been pressed, change to state 1
1C0E            354   
1C0E            355   START_ROUTINE: 
1C0E            356            ; We should add some code here that 
1C0E E4         357            clr a
1C0F C0E0       358            push acc
1C11 7401       358            mov a, #1
1C13 14         358            dec a
1C14 1202DF     358            lcall ?Set_Cursor_2 ; Select column and row
1C17 D0E0       358            pop acc
1C19 C083       359            push dph
1C1B C082       359            push dpl
1C1D C0E0       359            push acc
1C1F 90022D     359            mov dptr, #ISR_is_running
1C22 1202D4     359            lcall ?Send_Constant_String
1C25 D0E0       359            pop acc
1C27 D082       359            pop dpl
1C29 D083       359            pop dph
1C2B E552       360            mov a, reflow_state
1C2D            361            ;cjne a, #0x00, End_master_ISR
1C2D 755201     362            mov reflow_state, #0x01
1C30 803D       363            sjmp End_master_ISR
1C32            364   
1C32            365   
1C32            366   
1C32            367   STOP_ROUTINE: 
1C32 755205     368            mov reflow_state, #5    
1C35            369            ; any other things we want to do, ie, statements we want to make 
1C35            370   
1C35 C0E0       371            push acc
1C37 7401       371            mov a, #1
1C39 14         371            dec a
1C3A 1202E1     371            lcall ?Set_Cursor_1 ; Select column and row
1C3D D0E0       371            pop acc
1C3F C083       372            push dph
1C41 C082       372            push dpl
1C43 C0E0       372            push acc
1C45 90020B     372            mov dptr, #Abort_string
1C48 1202D4     372            lcall ?Send_Constant_String
1C4B D0E0       372            pop acc
1C4D D082       372            pop dpl
1C4F D083       372            pop dph
1C51            373   
1C51 C0E0       374            push acc
1C53 7401       374            mov a, #1
1C55 14         374            dec a
1C56 1202DF     374            lcall ?Set_Cursor_2 ; Select column and row
1C59 D0E0       374            pop acc
1C5B C083       375            push dph
1C5D C082       375            push dpl
1C5F C0E0       375            push acc
1C61 90021C     375            mov dptr, #Waiting_to_cool
1C64 1202D4     375            lcall ?Send_Constant_String
1C67 D0E0       375            pop acc
1C69 D082       375            pop dpl
1C6B D083       375            pop dph
1C6D            376   
1C6D 8000       377            sjmp End_master_ISR
1C6F            378   
1C6F            379   
1C6F            380   End_master_ISR: 
1C6F            381   ;        mov KBF, #1             ; enables interrupt
1C6F D0E0       382            pop acc
1C71            383   
1C71 32         384            reti
1C72            385   
1C72            386   
1C72            387   MainProgram:
1C72 75817F     388       mov SP, #7FH ; Set the stack pointer to the begining of idata
1C75 121A7D     389       lcall Start_stop_Init
1C78 1219C0     390            lcall seg_state_init
1C7B 1219E4     391       lcall Timer0_Init
1C7E 121A00     392            lcall Timer1_Init
1C81 121A1F     393       lcall Timer2_Init
1C84            394            
1C84 755200     395            mov reflow_state, #0x00
1C87            396       ; In case you decide to use the pins of P0, configure the port in bidirectional mode:
1C87 75E600     397       mov P0M0, #0
1C8A 75E700     398       mov P0M1, #0
1C8D            399            
1C8D 758E11     400            mov AUXR, #00010001B ; Max memory.  P4.4 is a general purpose IO pin
1C90            401   
1C90 D2AF       402       setb EA   ; Enable Global interrupts
1C92            403            
1C92 121312     404            lcall INIT_SPI
1C95 1202A8     405       lcall LCD_4BIT
1C98            406       
1C98            407   menu_forever:
1C98 020579     408       ljmp Main_Menu_Program
1C9B 1216C4     409            lcall GET_TEMP_DATA      ;This is the lab3 derivative loop that grabs the data from the thermocouple, 
1C9E            410            
1C9E            411   forever:
1C9E 1216C4     412            lcall GET_TEMP_DATA      ;This is the lab3 derivative loop that grabs the data from the thermocouple, 
1CA1 0216D3     413            ljmp reflow_state_machine       ; go do some stuff in the state_machine
1CA4            414   
1CA4            415   
1CA4 021C9E     416       ljmp forever ; This is equivalent to 'forever: sjmp forever'
1CA7            417   
1CA7            418       
1CA7            419   EN
