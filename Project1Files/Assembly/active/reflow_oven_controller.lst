                 -1   $MODLP51
0000              1   ;--------------------------------------------------------
0000              2   ; Special Function Registers
0000              3   ;--------------------------------------------------------
0000              4   ACC            DATA 0xe0
0000              5   B              DATA 0xf0
0000              6   PSW            DATA 0xd0
0000              7   SP             DATA 0x81
0000              8   SPX            DATA 0xef
0000              9   DPL            DATA 0x82
0000             10   DPH            DATA 0x83
0000             11   DPLB           DATA 0xd4
0000             12   DPHB           DATA 0xd5
0000             13   PAGE           DATA 0xf6
0000             14   AX             DATA 0xe1
0000             15   BX             DATA 0xf7
0000             16   DSPR           DATA 0xe2
0000             17   FIRD           DATA 0xe3
0000             18   MACL           DATA 0xe4
0000             19   MACH           DATA 0xe5
0000             20   PCON           DATA 0x87
0000             21   AUXR           DATA 0x8e
0000             22   AUXR1          DATA 0xa2
0000             23   DPCF           DATA 0xa1
0000             24   CKRL           DATA 0x97
0000             25   CKCKON0        DATA 0x8f
0000             26   CKCKON1        DATA 0xaf
0000             27   CKSEL          DATA 0x85
0000             28   CLKREG         DATA 0xae
0000             29   OSCCON         DATA 0x85
0000             30   IE             DATA 0xa8
0000             31   IEN0           DATA 0xa8
0000             32   IEN1           DATA 0xb1
0000             33   IPH0           DATA 0xb7
0000             34   IP             DATA 0xb8
0000             35   IPL0           DATA 0xb8
0000             36   IPH1           DATA 0xb3
0000             37   IPL1           DATA 0xb2
0000             38   P0             DATA 0x80
0000             39   P1             DATA 0x90
0000             40   P2             DATA 0xa0
0000             41   P3             DATA 0xb0
0000             42   P4             DATA 0xc0
0000             43   P0M0           DATA 0xe6
0000             44   P0M1           DATA 0xe7
0000             45   P1M0           DATA 0xd6
0000             46   P1M1           DATA 0xd7
0000             47   P2M0           DATA 0xce
0000             48   P2M1           DATA 0xcf
0000             49   P3M0           DATA 0xc6
0000             50   P3M1           DATA 0xc7
0000             51   P4M0           DATA 0xbe
0000             52   P4M1           DATA 0xbf
0000             53   SCON           DATA 0x98
0000             54   SBUF           DATA 0x99
0000             55   SADEN          DATA 0xb9
0000             56   SADDR          DATA 0xa9
0000             57   BDRCON         DATA 0x9b
0000             58   BRL            DATA 0x9a
0000             59   TCON           DATA 0x88
0000             60   TMOD           DATA 0x89
0000             61   TCONB          DATA 0x91
0000             62   TL0            DATA 0x8a
0000             63   TH0            DATA 0x8c
0000             64   TL1            DATA 0x8b
0000             65   TH1            DATA 0x8d
0000             66   RL0            DATA 0xf2
0000             67   RL1            DATA 0xf3
0000             68   RH0            DATA 0xf4
0000             69   RH1            DATA 0xf5
0000             70   WDTRST         DATA 0xa6
0000             71   WDTPRG         DATA 0xa7
0000             72   T2CON          DATA 0xc8
0000             73   T2MOD          DATA 0xc9
0000             74   RCAP2H         DATA 0xcb
0000             75   RCAP2L         DATA 0xca
0000             76   TH2            DATA 0xcd
0000             77   TL2            DATA 0xcc
0000             78   SPCON          DATA 0xc3
0000             79   SPSTA          DATA 0xc4
0000             80   SPDAT          DATA 0xc5
0000             81   SSCON          DATA 0x93
0000             82   SSCS           DATA 0x94
0000             83   SSDAT          DATA 0x95
0000             84   SSADR          DATA 0x96
0000             85   KBLS           DATA 0x9c
0000             86   KBE            DATA 0x9d
0000             87   KBF            DATA 0x9e
0000             88   KBMOD          DATA 0x9f
0000             89   BMSEL          DATA 0x92
0000             90   FCON           DATA 0xd2
0000             91   EECON          DATA 0xd2
0000             92   ACSRA          DATA 0xa3
0000             93   ACSRB          DATA 0xab
0000             94   AREF           DATA 0xbd
0000             95   DADC           DATA 0xa4
0000             96   DADI           DATA 0xa5
0000             97   DADL           DATA 0xac
0000             98   DADH           DATA 0xad
0000             99   CCON           DATA 0xd8
0000            100   CMOD           DATA 0xd9
0000            101   CL             DATA 0xe9
0000            102   CH             DATA 0xf9
0000            103   CCAPM0         DATA 0xda
0000            104   CCAPM1         DATA 0xdb
0000            105   CCAPM2         DATA 0xdc
0000            106   CCAPM3         DATA 0xdd
0000            107   CCAPM4         DATA 0xde
0000            108   CCAP0H         DATA 0xfa
0000            109   CCAP1H         DATA 0xfb
0000            110   CCAP2H         DATA 0xfc
0000            111   CCAP3H         DATA 0xfd
0000            112   CCAP4H         DATA 0xfe
0000            113   CCAP0L         DATA 0xea
0000            114   CCAP1L         DATA 0xeb
0000            115   CCAP2L         DATA 0xec
0000            116   CCAP3L         DATA 0xed
0000            117   CCAP4L         DATA 0xee
0000            118   ;--------------------------------------------------------
0000            119   ; special function bits
0000            120   ;--------------------------------------------------------
0000            121   P              BIT 0xd0
0000            122   F1             BIT 0xd1
0000            123   OV             BIT 0xd2
0000            124   RS0            BIT 0xd3
0000            125   RS1            BIT 0xd4
0000            126   F0             BIT 0xd5
0000            127   AC             BIT 0xd6
0000            128   CY             BIT 0xd7
0000            129   EX0            BIT 0xa8
0000            130   ET0            BIT 0xa9
0000            131   EX1            BIT 0xaa
0000            132   ET1            BIT 0xab
0000            133   ES             BIT 0xac
0000            134   ET2            BIT 0xad
0000            135   EC             BIT 0xae
0000            136   EA             BIT 0xaf
0000            137   PX0            BIT 0xb8
0000            138   PT0            BIT 0xb9
0000            139   PX1            BIT 0xba
0000            140   PT1            BIT 0xbb
0000            141   PS             BIT 0xbc
0000            142   PT2            BIT 0xbd
0000            143   IP0D           BIT 0xbf
0000            144   PPCL           BIT 0xbe
0000            145   PT2L           BIT 0xbd
0000            146   PLS            BIT 0xbc
0000            147   PT1L           BIT 0xbb
0000            148   PX1L           BIT 0xba
0000            149   PT0L           BIT 0xb9
0000            150   PX0L           BIT 0xb8
0000            151   RXD            BIT 0xb0
0000            152   TXD            BIT 0xb1
0000            153   INT0           BIT 0xb2
0000            154   INT1           BIT 0xb3
0000            155   T0             BIT 0xb4
0000            156   T1             BIT 0xb5
0000            157   WR             BIT 0xb6
0000            158   RD             BIT 0xb7
0000            159   RI             BIT 0x98
0000            160   TI             BIT 0x99
0000            161   RB8            BIT 0x9a
0000            162   TB8            BIT 0x9b
0000            163   REN            BIT 0x9c
0000            164   SM2            BIT 0x9d
0000            165   SM1            BIT 0x9e
0000            166   SM0            BIT 0x9f
0000            167   IT0            BIT 0x88
0000            168   IE0            BIT 0x89
0000            169   IT1            BIT 0x8a
0000            170   IE1            BIT 0x8b
0000            171   TR0            BIT 0x8c
0000            172   TF0            BIT 0x8d
0000            173   TR1            BIT 0x8e
0000            174   TF1            BIT 0x8f
0000            175   CP_RL2         BIT 0xc8
0000            176   C_T2           BIT 0xc9
0000            177   TR2            BIT 0xca
0000            178   EXEN2          BIT 0xcb
0000            179   TCLK           BIT 0xcc
0000            180   RCLK           BIT 0xcd
0000            181   EXF2           BIT 0xce
0000            182   TF2            BIT 0xcf
0000            183   CF             BIT 0xdf
0000            184   CR             BIT 0xde
0000            185   CCF4           BIT 0xdc
0000            186   CCF3           BIT 0xdb
0000            187   CCF2           BIT 0xda
0000            188   CCF1           BIT 0xd9
0000            189   CCF0           BIT 0xd8
0000              2   
0000              3   ; There is a couple of typos in MODLP51 in the definition of the timer 0/1 reload
0000              4   ; special function registers (SFRs), so:
0000              5   
0000              6   TIMER0_RELOAD_L DATA 0xf2
0000              7   TIMER1_RELOAD_L DATA 0xf3
0000              8   TIMER0_RELOAD_H DATA 0xf4
0000              9   TIMER1_RELOAD_H DATA 0xf5
0000             10   
0000             11   CLK              EQU 22118400 ; Microcontroller system crystal frequency in Hz
0000             12   TIMER0_RATE      EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             13   TIMER0_RELOAD    EQU ((65536-(CLK/TIMER0_RATE)))
0000             14   TIMER2_RATE      EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             15   TIMER2_RELOAD    EQU ((65536-(CLK/TIMER2_RATE)))
0000             16   MAX_TEMP              EQU 250
0000             17   TIMEOUT_TIME     EQU 60
0000             18   BAUD             EQU 115200
0000             19   BRG_VAL          EQU (0x100-(CLK/(16*BAUD)))
0000             20   MILLISECOND_WAIT EQU 200                 ; how many milliseconds between temp samples
0000             21   
0000             22   DUTY_0           EQU 0
0000             23   DUTY_20          EQU 51   ;256 * 0.2
0000             24   DUTY_50          EQU 128  ;256 * 0.5
0000             25   DUTY_80          EQU 204  ;256 * 0.8
0000             26   DUTY_100         EQU 255
0000             27   
0000             28   org 0x0000
0000 021485      29      ljmp MainProgram
0003             30   
0003             31   ; External interrupt 0 vector (not used in this code)
0003             32   org 0x0003
0003 32          33            reti
0004             34   
0004             35   ; Timer/Counter 0 overflow interrupt vector
000B             36   org 0x000B
000B 02137E      37            ljmp Timer0_ISR
000E             38   
000E             39   ; External interrupt 1 vector (not used in this code)
0013             40   org 0x0013
0013 32          41            reti
0014             42   
0014             43   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             44   org 0x001B
001B 32          45            reti
001C             46   
001C             47   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             48   org 0x0023 
0023 32          49            reti
0024             50            
0024             51   ; Timer/Counter 2 overflow interrupt vector
002B             52   org 0x002B
002B 0213B9      53            ljmp Timer2_ISR
002E             54   
002E             55   ;Edge triggered keyboard interrupt vector
003B             56   org 0x003B
003B 021409      57            ljmp Start_stop_ISR
003E             58   
003E             59   ; These ’EQU’ must match the wiring between the microcontroller and ADC
003E             60   SOUND_OUT     EQU P3.7
003E             61   CE_ADC        EQU P2.4
003E             62   MY_MOSI       EQU P2.5
003E             63   MY_MISO       EQU P2.6
003E             64   MY_SCLK       EQU P2.7
003E             65   
003E             66   UP_BUTTON          EQU P0.0
003E             67   DOWN_BUTTON   EQU P0.1
003E             68   SELECT_BUTTON EQU P0.2
003E             69   NEXT_BUTTON   EQU P0.3
003E             70   BACK_BUTTON   EQU p0.4
003E             71   
003E             72   MASTER_START  EQU p1.0
003E             73   
003E             74   MASTER_STOP   EQU p0.5
003E             75   
003E             76   
0030             77   DSEG at 0x30
0030             78   Count1ms:       ds 2 ; Used to determine when half second has passed
0032             79   Result:         ds 2 ; Temp from lm355
0034             80   Result_Thermo:  ds 2 ; Temp from Thermocoupler
0036             81   BCD_temp:       ds 2 ; Used to diplay temp on the 7-segment display
0038             82   seconds:        ds 1
0039             83   x:              ds 4 ; Used in math32
003D             84   y:              ds 4 ; Used in math32
0041             85   bcd:            ds 5
0046             86   soaktime:       ds 2
0048             87   soaktemp:       ds 2
004A             88   reflowtime:     ds 2
004C             89   reflowtemp:     ds 2
004E             90   soaktemp3digit: ds 2
0050             91   reflow_state:   ds 1
0051             92   pwm:            ds 1
0052             93   temp:           ds 1
0053             94   sec:            ds 1 ; seconds variable for reflow FSM (to be incremented every second)
0054             95   cooled_temp:    ds 1
0055             96   ; 7-segment vars
0055             97   Disp1:          ds 1 ; Least significant digit
0056             98   Disp2:          ds 1
0057             99   Disp3:          ds 1 ; Most significant digit
0058            100   seg_state:      ds 1 ; state of 7_seg fsm
0059            101   
0059            102   
0059            103   
0000            104   BSEG
0000            105   mf: dbit 1
0001            106   one_second_flag: dbit 1 
0002            107   
0002            108   
003E            109   CSEG
003E            110   LCD_RS equ P1.1
003E            111   LCD_RW equ P1.2
003E            112   LCD_E  equ P1.3
003E            113   LCD_D4 equ P3.2
003E            114   LCD_D5 equ P3.3
003E            115   LCD_D6 equ P3.4
003E            116   LCD_D7 equ P3.6
003E            117   
003E 50726568   118   Ramp_to_Soak:            db         'Preheat', 0
     65617400
0046 536F616B   119   Soak:                            db                 'Soak   ', 0
     20202000
004E 52616D70   120   Ramp_to_Peak:            db                 'Ramp2pk', 0
     32706B00
0056 5265666C   121   Reflow:                          db                 'Reflow ', 0
     6F772000
005E 436F6F6C   122   Cooling:                         db                 'Cooling', 0
     696E6700
0066 7300       123   secondsss:                       db                 's'          , 0
0068            124   ;                     1234567890123456    <- This helps determine the location of the counter
0068 57656C63   125   Welcome:                   db 'Welcome!        ', 0
     6F6D6521
     20202020
     20202020
     00
0079 53656C65   126   Choose_option:     db 'Select option   ', 0
     6374206F
     7074696F
     6E202020
     00
008A 50726573   127   Preset_menu_msg:  db 'Preset Profile  ', 0
     65742050
     726F6669
     6C652020
     00
009B 43757374   128   Custom_menu_msg:  db 'Custom Profile  ', 0
     6F6D2050
     726F6669
     6C652020
     00
00AC 536F616B   129   Soak_temp:                 db 'Soak Temp       ', 0
     2054656D
     70202020
     20202020
     00
00BD 536F616B   130   Soak_time:                 db 'Soak Time       ', 0
     2054696D
     65202020
     20202020
     00
00CE 5265666C   131   Reflow_time:       db 'Reflow Time     ', 0
     6F772054
     696D6520
     20202020
     00
00DF 5265666C   132   Reflow_temp:       db 'Reflow Temp     ', 0
     6F772054
     656D7020
     20202020
     00
00F0 53414333   133   Pb_free_solder:    db 'SAC305 solder   ', 0
     30352073
     6F6C6465
     72202020
     00
0101 50622D73   134   Pb_solder:                 db 'Pb-solder paste ', 0
     6F6C6465
     72207061
     73746520
     00
0112 53686868   135   Pizza_msg0:        db 'Shhh! No pizza  ', 0
     21204E6F
     2070697A
     7A612020
     00
0123 616C6C6F   136   Pizza_msg1:        db 'allowed in here.', 0
     77656420
     696E2068
     6572652E
     00
0134 70726F66   137   Profile_loaded:   db 'profile loaded  ', 0
     696C6520
     6C6F6164
     65642020
     00
0145 53797374   138   Is_ready:                  db 'System Ready    ', 0
     656D2052
     65616479
     20202020
     00
0156 50726573   139   Press_start:       db 'Press Start     ', 0
     73205374
     61727420
     20202020
     00
0167 78782020   140   Set_Value:                 db 'xx              ', 0
     20202020
     20202020
     20202020
     00
0178 20202020   141   Clear_Row:                 db '                ', 0
     20202020
     20202020
     20202020
     00
0189 41542050   142   PRESETMENUMSG:     db 'AT PRESET MENU  ', 0
     52455345
     54204D45
     4E552020
     00
019A 41542043   143   CUSTOMMENUMSG:     db 'AT CUSTOM MENU  ', 0
     5553544F
     4D204D45
     4E552020
     00
01AB 41726520   144   Are_you_sure:      db 'Are you sure?   ', 0
     796F7520
     73757265
     3F202020
     00
01BC 4572726F   145   Error_msg1:        db 'Error, profiles ', 0
     722C2070
     726F6669
     6C657320
     00
01CD 6E6F7420   146   Error_msg2:       db 'not loaded      ', 0
     6C6F6164
     65642020
     20202020
     00
01DE 50726F63   147   Abort_string:      db 'Process aborted ', 0
     65737320
     61626F72
     74656420
     00
01EF 57616974   148   Waiting_to_cool:  db 'Wait to cool    ', 0
     20746F20
     636F6F6C
     20202020
     00
0200            149   
0200            150   
                152   	$LIST
02AE            154   
                156   $LIST
0A55            158   
                546   $LIST
                  4   $LIST
0CC5              6   
                  7   Send_BCD mac
                  8   	push ar0
                  9   	mov r0, %0
                 10   	lcall ?Send_BCD
                 11   	mov a, #'\r'
                 12       lcall putchar
                 13       mov a, #'\n'
                 14       lcall putchar
                 15   	pop ar0
                 16   endmac
0CC5             17   
0CC5             18   ; Configure the serial port and baud rate
0CC5             19   InitSerialPort:
0CC5             20       ; Since the reset button bounces, we need to wait a bit before
0CC5             21       ; sending messages, otherwise we risk displaying gibberish!
0CC5 79DE        22       mov R1, #222
0CC7 78A6        23       mov R0, #166
0CC9 D8FE        24       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
0CCB D9FA        25       djnz R1, $-4 ; 22.51519us*222=4.998ms
0CCD             26       ; Now we can proceed with the configuration
0CCD 438780      27            orl     PCON,#0x80
0CD0 759852      28            mov     SCON,#0x52
0CD3 759B00      29            mov     BDRCON,#0x00
0CD6 759AF4      30            mov     BRL,#BRG_VAL
0CD9 759B1E      31            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0CDC 22          32       ret
0CDD             33   
0CDD             34   ; Send a character using the serial port
0CDD             35   putchar:
0CDD 3099FD      36       jnb TI, putchar
0CE0 C299        37       clr TI
0CE2 F599        38       mov SBUF, a
0CE4 22          39       ret
0CE5             40   
0CE5             41   ; Send a constant-zero-terminated string using the serial port
0CE5             42   SendString:
0CE5 E4          43       clr A
0CE6 93          44       movc A, @A+DPTR
0CE7 6006        45       jz SendStringDone
0CE9 120CDD      46       lcall putchar
0CEC A3          47       inc DPTR
0CED 80F6        48       sjmp SendString
0CEF             49   SendStringDone:
0CEF 22          50       ret
0CF0             51       
0CF0             52   INIT_SPI:
0CF0 D2A6        53            setb MY_MISO ; Make MISO an input pin
0CF2 C2A7        54            clr MY_SCLK ; For mode (0,0) SCLK is zero
0CF4 22          55            ret
0CF5             56   
0CF5             57   DO_SPI_G:
0CF5 C0E0        58            push acc
0CF7 7900        59            mov R1, #0 ; Received byte stored in R1
0CF9 7A08        60            mov R2, #8 ; Loop counter (8-bits)
0CFB             61   DO_SPI_G_LOOP:
0CFB E8          62            mov a, R0 ; Byte to write is in R0
0CFC 33          63            rlc a ; Carry flag has bit to write
0CFD F8          64            mov R0, a
0CFE 92A5        65            mov MY_MOSI, c
0D00 D2A7        66            setb MY_SCLK ; Transmit
0D02 A2A6        67            mov c, MY_MISO ; Read received bit
0D04 E9          68            mov a, R1 ; Save received bit in R1
0D05 33          69            rlc a
0D06 F9          70            mov R1, a
0D07 C2A7        71            clr MY_SCLK
0D09 DAF0        72            djnz R2, DO_SPI_G_LOOP
0D0B D0E0        73            pop acc
0D0D 22          74            ret
0D0E             75    
0D0E             76   Hello_World:
0D0E 48656C6C    77       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
0D1E             78       
0D1E             79   Delay:
0D1E 79DE        80            mov R1, #222
0D20 78A6        81       mov R0, #166
0D22 D8FE        82       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
0D24 D9FA        83       djnz R1, $-4 ; 22.51519us*222=4.998ms
0D26 32          84       reti
0D27             85       
                 86   Left_blank mac
                 87   	mov a, %0
                 88   	anl a, #0xf0
                 89   	swap a
                 90   	jz Left_blank_%M_a
                 91   	ljmp %1
                 92   Left_blank_%M_a:
                 93   	Display_char(#' ')
                 94   	mov a, %0
                 95   	anl a, #0x0f
                 96   	jz Left_blank_%M_b
                 97   	ljmp %1
                 98   Left_blank_%M_b:
                 99   	Display_char(#' ')
                100   endmac
0D27            101      
0D27            102   ; Sends 10-digit BCD number in bcd to the LCD 
0D27            103   Display_10_digit_BCD:
0D27 C0E0       104            push acc
0D29 7407       104            mov a, #7
0D2B 14         104            dec a
0D2C 120291     104            lcall ?Set_Cursor_2 ; Select column and row
0D2F D0E0       104            pop acc
0D31 C000       105            push ar0
0D33 A845       105            mov r0, bcd+4
0D35 120298     105            lcall ?Display_BCD
0D38 D000       105            pop ar0
0D3A C000       106            push ar0
0D3C A844       106            mov r0, bcd+3
0D3E 120298     106            lcall ?Display_BCD
0D41 D000       106            pop ar0
0D43 C000       107            push ar0
0D45 A843       107            mov r0, bcd+2
0D47 120298     107            lcall ?Display_BCD
0D4A D000       107            pop ar0
0D4C C000       108            push ar0
0D4E A842       108            mov r0, bcd+1
0D50 120298     108            lcall ?Display_BCD
0D53 D000       108            pop ar0
0D55 C000       109            push ar0
0D57 A841       109            mov r0, bcd+0
0D59 120298     109            lcall ?Display_BCD
0D5C D000       109            pop ar0
0D5E            110            ; Replace all the zeros to the left with blanks
0D5E C0E0       111            push acc
0D60 7407       111            mov a, #7
0D62 14         111            dec a
0D63 120291     111            lcall ?Set_Cursor_2 ; Select column and row
0D66 D0E0       111            pop acc
0D68 E545       112            mov a, bcd+4
0D6A 54F0       112            anl a, #0xf0
0D6C C4         112            swap a
0D6D 6003       112            jz Left_blank_145_a
0D6F 020E0C     112            ljmp skip_blank
0D72            112   Left_blank_145_a:
0D72 C0E0       112            push acc
0D74 7420       112            mov a, #' '
0D76 120250     112            lcall ?WriteData
0D79 D0E0       112            pop acc
0D7B E545       112            mov a, bcd+4
0D7D 540F       112            anl a, #0x0f
0D7F 6003       112            jz Left_blank_145_b
0D81 020E0C     112            ljmp skip_blank
0D84            112   Left_blank_145_b:
0D84 C0E0       112            push acc
0D86 7420       112            mov a, #' '
0D88 120250     112            lcall ?WriteData
0D8B D0E0       112            pop acc
0D8D E544       113            mov a, bcd+3
0D8F 54F0       113            anl a, #0xf0
0D91 C4         113            swap a
0D92 6003       113            jz Left_blank_148_a
0D94 020E0C     113            ljmp skip_blank
0D97            113   Left_blank_148_a:
0D97 C0E0       113            push acc
0D99 7420       113            mov a, #' '
0D9B 120250     113            lcall ?WriteData
0D9E D0E0       113            pop acc
0DA0 E544       113            mov a, bcd+3
0DA2 540F       113            anl a, #0x0f
0DA4 6003       113            jz Left_blank_148_b
0DA6 020E0C     113            ljmp skip_blank
0DA9            113   Left_blank_148_b:
0DA9 C0E0       113            push acc
0DAB 7420       113            mov a, #' '
0DAD 120250     113            lcall ?WriteData
0DB0 D0E0       113            pop acc
0DB2 E543       114            mov a, bcd+2
0DB4 54F0       114            anl a, #0xf0
0DB6 C4         114            swap a
0DB7 6003       114            jz Left_blank_151_a
0DB9 020E0C     114            ljmp skip_blank
0DBC            114   Left_blank_151_a:
0DBC C0E0       114            push acc
0DBE 7420       114            mov a, #' '
0DC0 120250     114            lcall ?WriteData
0DC3 D0E0       114            pop acc
0DC5 E543       114            mov a, bcd+2
0DC7 540F       114            anl a, #0x0f
0DC9 6003       114            jz Left_blank_151_b
0DCB 020E0C     114            ljmp skip_blank
0DCE            114   Left_blank_151_b:
0DCE C0E0       114            push acc
0DD0 7420       114            mov a, #' '
0DD2 120250     114            lcall ?WriteData
0DD5 D0E0       114            pop acc
0DD7 E542       115            mov a, bcd+1
0DD9 54F0       115            anl a, #0xf0
0DDB C4         115            swap a
0DDC 6003       115            jz Left_blank_154_a
0DDE 020E0C     115            ljmp skip_blank
0DE1            115   Left_blank_154_a:
0DE1 C0E0       115            push acc
0DE3 7420       115            mov a, #' '
0DE5 120250     115            lcall ?WriteData
0DE8 D0E0       115            pop acc
0DEA E542       115            mov a, bcd+1
0DEC 540F       115            anl a, #0x0f
0DEE 6003       115            jz Left_blank_154_b
0DF0 020E0C     115            ljmp skip_blank
0DF3            115   Left_blank_154_b:
0DF3 C0E0       115            push acc
0DF5 7420       115            mov a, #' '
0DF7 120250     115            lcall ?WriteData
0DFA D0E0       115            pop acc
0DFC E541       116            mov a, bcd+0
0DFE 54F0       117            anl a, #0f0h
0E00 C4         118            swap a
0E01 7009       119            jnz skip_blank
0E03 C0E0       120            push acc
0E05 7420       120            mov a, #' '
0E07 120250     120            lcall ?WriteData
0E0A D0E0       120            pop acc
0E0C            121   skip_blank:
0E0C 22         122            ret
0E0D            123            
0E0D            124   Display_10_digit_BCD_2:
0E0D C0E0       125            push acc
0E0F 7407       125            mov a, #7
0E11 14         125            dec a
0E12 120293     125            lcall ?Set_Cursor_1 ; Select column and row
0E15 D0E0       125            pop acc
0E17 C000       126            push ar0
0E19 A845       126            mov r0, bcd+4
0E1B 120298     126            lcall ?Display_BCD
0E1E D000       126            pop ar0
0E20 C000       127            push ar0
0E22 A844       127            mov r0, bcd+3
0E24 120298     127            lcall ?Display_BCD
0E27 D000       127            pop ar0
0E29 C000       128            push ar0
0E2B A843       128            mov r0, bcd+2
0E2D 120298     128            lcall ?Display_BCD
0E30 D000       128            pop ar0
0E32 C000       129            push ar0
0E34 A842       129            mov r0, bcd+1
0E36 120298     129            lcall ?Display_BCD
0E39 D000       129            pop ar0
0E3B C000       130            push ar0
0E3D A841       130            mov r0, bcd+0
0E3F 120298     130            lcall ?Display_BCD
0E42 D000       130            pop ar0
0E44            131            ; Replace all the zeros to the left with blanks
0E44 C0E0       132            push acc
0E46 7407       132            mov a, #7
0E48 14         132            dec a
0E49 120293     132            lcall ?Set_Cursor_1 ; Select column and row
0E4C D0E0       132            pop acc
0E4E E545       133            mov a, bcd+4
0E50 54F0       133            anl a, #0xf0
0E52 C4         133            swap a
0E53 6003       133            jz Left_blank_165_a
0E55 020EF2     133            ljmp skip_blank_2
0E58            133   Left_blank_165_a:
0E58 C0E0       133            push acc
0E5A 7420       133            mov a, #' '
0E5C 120250     133            lcall ?WriteData
0E5F D0E0       133            pop acc
0E61 E545       133            mov a, bcd+4
0E63 540F       133            anl a, #0x0f
0E65 6003       133            jz Left_blank_165_b
0E67 020EF2     133            ljmp skip_blank_2
0E6A            133   Left_blank_165_b:
0E6A C0E0       133            push acc
0E6C 7420       133            mov a, #' '
0E6E 120250     133            lcall ?WriteData
0E71 D0E0       133            pop acc
0E73 E544       134            mov a, bcd+3
0E75 54F0       134            anl a, #0xf0
0E77 C4         134            swap a
0E78 6003       134            jz Left_blank_168_a
0E7A 020EF2     134            ljmp skip_blank_2
0E7D            134   Left_blank_168_a:
0E7D C0E0       134            push acc
0E7F 7420       134            mov a, #' '
0E81 120250     134            lcall ?WriteData
0E84 D0E0       134            pop acc
0E86 E544       134            mov a, bcd+3
0E88 540F       134            anl a, #0x0f
0E8A 6003       134            jz Left_blank_168_b
0E8C 020EF2     134            ljmp skip_blank_2
0E8F            134   Left_blank_168_b:
0E8F C0E0       134            push acc
0E91 7420       134            mov a, #' '
0E93 120250     134            lcall ?WriteData
0E96 D0E0       134            pop acc
0E98 E543       135            mov a, bcd+2
0E9A 54F0       135            anl a, #0xf0
0E9C C4         135            swap a
0E9D 6003       135            jz Left_blank_171_a
0E9F 020EF2     135            ljmp skip_blank_2
0EA2            135   Left_blank_171_a:
0EA2 C0E0       135            push acc
0EA4 7420       135            mov a, #' '
0EA6 120250     135            lcall ?WriteData
0EA9 D0E0       135            pop acc
0EAB E543       135            mov a, bcd+2
0EAD 540F       135            anl a, #0x0f
0EAF 6003       135            jz Left_blank_171_b
0EB1 020EF2     135            ljmp skip_blank_2
0EB4            135   Left_blank_171_b:
0EB4 C0E0       135            push acc
0EB6 7420       135            mov a, #' '
0EB8 120250     135            lcall ?WriteData
0EBB D0E0       135            pop acc
0EBD E542       136            mov a, bcd+1
0EBF 54F0       136            anl a, #0xf0
0EC1 C4         136            swap a
0EC2 6003       136            jz Left_blank_174_a
0EC4 020EF2     136            ljmp skip_blank_2
0EC7            136   Left_blank_174_a:
0EC7 C0E0       136            push acc
0EC9 7420       136            mov a, #' '
0ECB 120250     136            lcall ?WriteData
0ECE D0E0       136            pop acc
0ED0 E542       136            mov a, bcd+1
0ED2 540F       136            anl a, #0x0f
0ED4 6003       136            jz Left_blank_174_b
0ED6 020EF2     136            ljmp skip_blank_2
0ED9            136   Left_blank_174_b:
0ED9 C0E0       136            push acc
0EDB 7420       136            mov a, #' '
0EDD 120250     136            lcall ?WriteData
0EE0 D0E0       136            pop acc
0EE2 E541       137            mov a, bcd+0
0EE4 54F0       138            anl a, #0f0h
0EE6 C4         139            swap a
0EE7 7009       140            jnz skip_blank_2
0EE9 C0E0       141            push acc
0EEB 7420       141            mov a, #' '
0EED 120250     141            lcall ?WriteData
0EF0 D0E0       141            pop acc
0EF2            142   skip_blank_2:
0EF2 22         143            ret
0EF3            144   
0EF3            145            ; Sends 10-digit BCD number in BCD to the SPI
0EF3            146   Send_10_digit_BCD:
0EF3 C000       147            push ar0
0EF5 A845       147            mov r0, bcd+4
0EF7 120F53     147            lcall ?Send_BCD
0EFA 740D       147            mov a, #'\r'
0EFC 120CDD     147       lcall putchar
0EFF 740A       147       mov a, #'\n'
0F01 120CDD     147       lcall putchar
0F04 D000       147            pop ar0
0F06 C000       148            push ar0
0F08 A844       148            mov r0, bcd+3
0F0A 120F53     148            lcall ?Send_BCD
0F0D 740D       148            mov a, #'\r'
0F0F 120CDD     148       lcall putchar
0F12 740A       148       mov a, #'\n'
0F14 120CDD     148       lcall putchar
0F17 D000       148            pop ar0
0F19 C000       149            push ar0
0F1B A843       149            mov r0, bcd+2
0F1D 120F53     149            lcall ?Send_BCD
0F20 740D       149            mov a, #'\r'
0F22 120CDD     149       lcall putchar
0F25 740A       149       mov a, #'\n'
0F27 120CDD     149       lcall putchar
0F2A D000       149            pop ar0
0F2C C000       150            push ar0
0F2E A842       150            mov r0, bcd+1
0F30 120F53     150            lcall ?Send_BCD
0F33 740D       150            mov a, #'\r'
0F35 120CDD     150       lcall putchar
0F38 740A       150       mov a, #'\n'
0F3A 120CDD     150       lcall putchar
0F3D D000       150            pop ar0
0F3F C000       151            push ar0
0F41 A841       151            mov r0, bcd+0
0F43 120F53     151            lcall ?Send_BCD
0F46 740D       151            mov a, #'\r'
0F48 120CDD     151       lcall putchar
0F4B 740A       151       mov a, #'\n'
0F4D 120CDD     151       lcall putchar
0F50 D000       151            pop ar0
0F52 22         152            ret
0F53            153   
0F53            154   ?Send_BCD:
0F53 C0E0       155            push acc
0F55            156            ; Write most significant digit
0F55 E8         157            mov a, r0
0F56 C4         158            swap a
0F57 540F       159            anl a, #0fh
0F59 4430       160            orl a, #30h
0F5B 120CDD     161            lcall putchar
0F5E            162            ; write least significant digit
0F5E E8         163            mov a, r0
0F5F 540F       164            anl a, #0fh
0F61 4430       165            orl a, #30h
0F63 120CDD     166            lcall putchar
0F66 D0E0       167            pop acc
0F68 22         168            ret
0F69            169   
0F69            170   GET_ADC_TEMP:
0F69 C2A4       171       clr CE_ADC         ; selects 
0F6B 7801       172       mov R0, #00000001B ; Start bit: 1
0F6D 120CF5     173       lcall DO_SPI_G
0F70            174       
0F70 7880       175       mov R0, #10000000B ; Read channel 0
0F72 120CF5     176       lcall DO_SPI_G
0F75 E9         177       mov a, R1
0F76 5403       178       anl a, #00000011B
0F78 F533       179       mov Result+1, a    ; Save high result
0F7A            180       
0F7A 7855       181       mov R0, #55H
0F7C 120CF5     182       lcall DO_SPI_G
0F7F 8932       183       mov Result, R1     ; Save low result
0F81            184       
0F81 D2A4       185       setb CE_ADC        ; deselects
0F83            186       
0F83            187       ;V_OUT = ADC_voltage*4.096V/1023
0F83            188       ;ADC_voltage*4096 = A
0F83 853239     189       mov x+0, Result
0F86 85333A     190       mov x+1, Result+1
0F89 753B00     191       mov x+2, #0
0F8C 753C00     192       mov x+3, #0
0F8F            193       
0F8F 22         194    ret
0F90            195   
0F90            196    GET_THERMO_TEMP:
0F90 C2A4       197       clr CE_ADC         ; selects 
0F92 7801       198       mov R0, #00000001B ; Start bit: 1
0F94 120CF5     199       lcall DO_SPI_G
0F97            200       
0F97 7890       201       mov R0, #10010000B ; Read channel 1
0F99 120CF5     202       lcall DO_SPI_G
0F9C E9         203       mov a, R1
0F9D 5403       204       anl a, #00000011B
0F9F F535       205       mov Result_Thermo+1, a    ; Save high result
0FA1            206       
0FA1 7855       207       mov R0, #55H
0FA3 120CF5     208       lcall DO_SPI_G
0FA6 8934       209       mov Result_Thermo, R1     ; Save low result
0FA8 D2A4       210       setb CE_ADC        ; deselects
0FAA            211       
0FAA            212       ;V_OUT = ADC_voltage*4.096V/1023
0FAA            213       ;ADC_voltage*4096 = A
0FAA 853439     214       mov x+0, Result_Thermo
0FAD 85353A     215       mov x+1, Result_Thermo+1
0FB0 753B00     216       mov x+2, #0
0FB3 753C00     217       mov x+3, #0
0FB6 22         218     ret
0FB7            219   
0FB7            220   ;____________________________________
0FB7            221    ;*************************************
0FB7            222   
0FB7            223   ; This is the code that converts the amplified voltage from the the k-type thermocouple 
0FB7            224   ; to temperature data for use. 
0FB7            225   ; Current Parameters: 
0FB7            226   ;                Op-amp gain: ~200
0FB7            227   ;                Thermocouple conversion: 41 uV/celcius
0FB7            228   ;                Reference Voltage: 4.096 
0FB7            229   ; inputs
0FB7            230   ;*************************************           
0FB7            231   ;-------------------------------------           
0FB7            232   
0FB7            233   Voltage_to_temp_LM355: 
0FB7 753D00     234            mov y+0, #low (4096 % 0x10000) 
0FBA 753E10     234            mov y+1, #high(4096 % 0x10000) 
0FBD 753F00     234            mov y+2, #low (4096 / 0x10000) 
0FC0 754000     234            mov y+3, #high(4096 / 0x10000) 
0FC3 120BCF     235                        lcall mul32 ;multiplies x *= y
0FC6            236                        
0FC6            237                        ;A/1023 = B
0FC6 753DFF     238            mov y+0, #low (1023 % 0x10000) 
0FC9 753E03     238            mov y+1, #high(1023 % 0x10000) 
0FCC 753F00     238            mov y+2, #low (1023 / 0x10000) 
0FCF 754000     238            mov y+3, #high(1023 / 0x10000) 
0FD2 120C5C     239                        lcall div32 ;divides x /= y
0FD5            240                        
0FD5            241                        ;B - 2730 = C
0FD5 753DAA     242            mov y+0, #low (2730 % 0x10000) 
0FD8 753E0A     242            mov y+1, #high(2730 % 0x10000) 
0FDB 753F00     242            mov y+2, #low (2730 / 0x10000) 
0FDE 754000     242            mov y+3, #high(2730 / 0x10000) ;
0FE1 120B3B     243                        lcall sub32
0FE4            244                        
0FE4            245                        ;B/10 = V_OUT
0FE4 753D0A     246            mov y+0, #low (10 % 0x10000) 
0FE7 753E00     246            mov y+1, #high(10 % 0x10000) 
0FEA 753F00     246            mov y+2, #low (10 / 0x10000) 
0FED 754000     246            mov y+3, #high(10 / 0x10000) ;
0FF0 120C5C     247                        lcall div32 ;divides x /= y
0FF3 120A55     248                            lcall hex2bcd
0FF6 22         249            ret
0FF7            250   
0FF7            251   Voltage_to_temp_thermocouple: 
0FF7            252   
0FF7            253            ;SPI_REF_VOLTAGE_mul100 equ 4081
0FF7            254            ;THERMOCOUPLE_CONVERSION_div1000 equ 2475
0FF7            255            
0FF7            256            ;
0FF7            257            ; We are doing the conversion from V--> 10 bit Temp (deg C)
0FF7            258            ; Start: Amplified Volts, Vin
0FF7            259            ;
0FF7            260            ;               Vin*(1 deg C)* (V_REF)*    1    * 1
0FF7            261            ;                        --------                           ---    ---  - ADC_RESULT
0FF7            262            ;                       (41 uV )                   OP_AMP_GAIn  1023
0FF7            263   
0FF7 753DF1     264            mov y+0, #low (4081 % 0x10000) 
0FFA 753E0F     264            mov y+1, #high(4081 % 0x10000) 
0FFD 753F00     264            mov y+2, #low (4081 / 0x10000) 
1000 754000     264            mov y+3, #high(4081 / 0x10000) ; 4.081*1000=mV
1003 120BCF     265            lcall mul32
1006            266            
1006 753DFF     267            mov y+0, #low (1023 % 0x10000) 
1009 753E03     267            mov y+1, #high(1023 % 0x10000) 
100C 753F00     267            mov y+2, #low (1023 / 0x10000) 
100F 754000     267            mov y+3, #high(1023 / 0x10000) 
1012 120C5C     268            lcall div32   
1015            269            
1015 753DF7     270            mov y+0, #low (247 % 0x10000) 
1018 753E00     270            mov y+1, #high(247 % 0x10000) 
101B 753F00     270            mov y+2, #low (247 / 0x10000) 
101E 754000     270            mov y+3, #high(247 / 0x10000)  ; 24.75*10
1021 120BCF     271            lcall mul32
1024            272                                    ;---------
1024 753D02     273            mov y+0, #low (2050 % 0x10000) 
1027 753E08     273            mov y+1, #high(2050 % 0x10000) 
102A 753F00     273            mov y+2, #low (2050 / 0x10000) 
102D 754000     273            mov y+3, #high(2050 / 0x10000)  ; 205*10
1030 120C5C     274            lcall div32
1033            275            
1033 753D16     276            mov y+0, #low (22 % 0x10000) 
1036 753E00     276            mov y+1, #high(22 % 0x10000) 
1039 753F00     276            mov y+2, #low (22 / 0x10000) 
103C 754000     276            mov y+3, #high(22 / 0x10000) 
103F            277   
103F            278   
103F 120B1A     279            lcall add32
1042            280            
1042 120A55     281            lcall hex2bcd
1045 22         282      ret
1046            283   
1046            284   
1046            285   GET_TEMP_DATA: 
1046 300117     286            jnb one_second_flag, GET_TEMP_DATA_END
1049 C201       287            clr one_second_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
104B            288            
104B            289            ;Gets, displays, and pushes ADC LM355 temp values
104B 120F69     290            lcall GET_ADC_TEMP
104E 120FB7     291       lcall Voltage_to_temp_LM355
1051 120D27     292       lcall Display_10_digit_BCD
1054            293       
1054            294       ; Gets, displays, and pushes k-type thermocouple vlaues
1054 120F90     295            lcall GET_THERMO_TEMP
1057 120FF7     296       lcall Voltage_to_temp_thermocouple
105A 120EF3     297       lcall Send_10_digit_BCD
105D 120E0D     298       lcall Display_10_digit_BCD_2
1060            299       
1060            300       ;lcall Delay
1060            301    GET_TEMP_DATA_END:
1060 22         302       ret
1061            303            
1061            304   
1061            305   
1061            306   EN
                160   $LIST
1061            162   
                164   $LIST
12E5            166   
                168   $LIST
1365            170   
1365            171   ;----------------------------------------MACRO LOCATION----------------------------------------------
1365            172   
1365            173   
1365            174   
1365            175   
1365            176   ;---------------------------------;
1365            177   ; Routine to initialize the ISR   ;
1365            178   ; for timer 0                     ;
1365            179   ;---------------------------------;
1365            180   Timer0_Init:
1365 E589       181            mov a, TMOD
1367 54F0       182            anl a, #0xf0 ; Clear the bits for timer 0
1369 4401       183            orl a, #0x01 ; Configure timer 0 as 16-timer
136B F589       184            mov TMOD, a
136D 758CEA     185            mov TH0, #high(TIMER0_RELOAD)
1370 758AE8     186            mov TL0, #low(TIMER0_RELOAD)
1373            187            ; Set autoreload value
1373 75F4EA     188            mov TIMER0_RELOAD_H, #high(TIMER0_RELOAD)
1376 75F2E8     189            mov TIMER0_RELOAD_L, #low(TIMER0_RELOAD)
1379            190            ; Enable the timer and interrupts
1379 D2A9       191       setb ET0  ; Enable timer 0 interrupt
137B D28C       192       setb TR0  ; Start timer 0
137D 22         193            ret
137E            194   
137E            195   ;---------------------------------;
137E            196   ; ISR for timer 0.  Set to execute;
137E            197   ; every 1/4096Hz to generate a    ;
137E            198   ; 2048 Hz square wave at pin P3.7 ;
137E            199   ;---------------------------------;
137E            200   Timer0_ISR:
137E            201            ;clr TF0  ; According to the data sheet this is done for us already.
137E 8000       202            sjmp no_beep
1380            203   beep_on:
1380            204            ;cpl SOUND_OUT ; Connect speaker to P3.7!
1380            205   no_beep:
1380 32         206            reti
1381            207            
1381            208   ;---------------------------------;
1381            209   ; Routine to initialize the ISR   ;
1381            210   ; for timer 1 in PWM mode         ;
1381            211   ;---------------------------------;
1381            212   
1381            213   Timer1_Init:
1381 E589       214            mov a, TMOD
1383 540F       215            anl a, #00001111B       ;Clears timer 1 settings but keeps timer 0 settings
1385 4410       216            orl a, #00010000B       ;Gate = 0, TC1 = 0, mode = 01 (mode 1)
1387 F589       217            mov TMOD, a
1389            218            
1389 E591       219            mov a, TCONB            ;load TCONB for PWM settings
138B 5400       220            anl a, #00000000B       ;clear TCONB
138D 4480       221            orl a, #10000000B       ;Set PWM1 = 1
138F F591       222            mov TCONB, a
1391            223            
1391 758D00     224            mov TH1, #0             ;Current count value
1394 758B00     225            mov TL1, #0             ;Linear Prescaling
1397            226            
1397 75F500     227            mov TIMER1_RELOAD_H, #DUTY_0 ;Duty cycle percentage. Replace this value to change the duty cycle
139A 75F300     228            mov TIMER1_RELOAD_L, #0      ;Frequency scaling/adjust f_out = f_sys/(256 * (256 - TL))
139D            229            
139D D28E       230            setb TR1
139F 32         231            reti
13A0            232   
13A0            233   ;---------------------------------;
13A0            234   ; Routine to initialize the ISR   ;
13A0            235   ; for timer 2                     ;
13A0            236   ;---------------------------------;
13A0            237   Timer2_Init:
13A0 75C800     238            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
13A3 75CDA9     239            mov TH2, #high(TIMER2_RELOAD)
13A6 75CC9A     240            mov TL2, #low(TIMER2_RELOAD)
13A9            241            ; Set the reload value
13A9 75CBA9     242            mov RCAP2H, #high(TIMER2_RELOAD)
13AC 75CA9A     243            mov RCAP2L, #low(TIMER2_RELOAD)
13AF            244            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
13AF E4         245            clr a
13B0 F530       246            mov Count1ms+0, a
13B2 F531       247            mov Count1ms+1, a
13B4            248            ; Enable the timer and interrupts
13B4 D2AD       249       setb ET2  ; Enable timer 2 interrupt
13B6 D2CA       250       setb TR2  ; Enable timer 2
13B8 22         251            ret
13B9            252   
13B9            253   ;---------------------------------;
13B9            254   ; ISR for timer 2                 ;
13B9            255   ;---------------------------------;
13B9            256   Timer2_ISR:
13B9 C2CF       257            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
13BB            258            
13BB            259            ; The two registers used in the ISR must be saved in the stack
13BB C0E0       260            push acc
13BD C0D0       261            push psw
13BF            262            
13BF            263            ; Increment the 16-bit one mili second counter
13BF            264                            ;       inc Count1ms+0    ; Increment the low 8-bits first
13BF            265                                    ;mov a, Count1ms+0
13BF            266                            ;       cjne a, #10h, Timer2_ISR_done
13BF            267                            ;       mov Count1ms+0, #0h
13BF 0530       268            inc Count1ms+0    ; Increment the low 8-bits first
13C1 E530       269            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
13C3 7015       270            jnz Inc_Done
13C5 0531       271            inc Count1ms+1
13C7            272            
13C7 C000       273            push ar0
13C9 A841       273            mov r0, bcd
13CB 120F53     273            lcall ?Send_BCD
13CE 740D       273            mov a, #'\r'
13D0 120CDD     273       lcall putchar
13D3 740A       273       mov a, #'\n'
13D5 120CDD     273       lcall putchar
13D8 D000       273            pop ar0
13DA            274            Inc_Done:
13DA            275            ; Check if a second has passed
13DA            276   
13DA E530       277            mov a, Count1ms+0
13DC B4C815     278            cjne a, #low(MILLISECOND_WAIT), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
13DF E531       279            mov a, Count1ms+1
13E1 B40010     280            cjne a, #high(MILLISECOND_WAIT), Timer2_ISR_done
13E4            281            
13E4            282            ; 1000 milliseconds have passed.  Set a flag so the main program knows
13E4 D201       283            setb one_second_flag ; Let the main program know one second had passed
13E6 B28C       284            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
13E8            285            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
13E8 E4         286            clr a
13E9 F530       287            mov Count1ms+0, a
13EB F531       288            mov Count1ms+1, a
13ED            289            ; Increment the BCD counter
13ED E538       290            mov a, seconds
13EF 2401       291            add a, #0x01
13F1 D4         292            da a ; Decimal adjust instruction.  Check datasheet for more details!
13F2 F538       293            mov seconds, a
13F4            294            
13F4            295            
13F4            296   Timer2_ISR_done:
13F4 121306     297            lcall seg_state_machine
13F7            298   
13F7 D0D0       299            pop psw
13F9 D0E0       300            pop acc
13FB 32         301            reti
13FC            302   
13FC            303   
13FC            304   ;-------------------------------------
13FC            305   ; To start or ABORT the reflow cycle
13FC            306   ;------------------------------------
13FC            307   Start_stop_Init: 
13FC            308            
13FC 759F03     309            mov KBMOD, #3   ; enable edge triggered for P0.0 and P0.1
13FF 759C00     310            mov KBLS, #0    ; watch for negative edge (0->1)
1402 759D03     311            mov KBE, #3     ; enable interrupt for p0.0 and p0.1
1405 759E03     312            mov KBF, #3; interrupt active, must clear at start of ISR and setb at end. 
1408            313   
1408 22         314            ret
1409            315   
1409            316   Start_stop_ISR: 
1409 759E00     317   mov KBF, #0              ; masks interrupt 
140C C0E0       318   push acc
140E            319   
140E 208512     320   jb MASTER_STOP, endhere_233
1411 C002       320            push AR2
1413 7A32       320            mov R2, #50
1415 12020B     320            lcall ?Wait_Milli_Seconds
1418 D002       320            pop AR2
141A 208506     320   jb MASTER_STOP, endhere_233
141D 3085FD     320   jnb MASTER_STOP, $
1420 021442     320   ljmp STOP_ROUTINE
1423            320   
1423            320   endhere_233:                             ; if master stop has been pressed, change to state 5
1423            321   
1423 209012     322   jb MASTER_START, endhere_235
1426 C002       322            push AR2
1428 7A32       322            mov R2, #50
142A 12020B     322            lcall ?Wait_Milli_Seconds
142D D002       322            pop AR2
142F 209006     322   jb MASTER_START, endhere_235
1432 3090FD     322   jnb MASTER_START, $
1435 021438     322   ljmp START_ROUTINE
1438            322   
1438            322   endhere_235:                      ; if master start has been pressed, change to state 1
1438            323   
1438            324   START_ROUTINE: 
1438            325            ; We should add some code here that 
1438            326   
1438            327   
1438 E550       328            mov a, reflow_state
143A B40042     329            cjne a, #0, End_master_ISR
143D 755001     330            mov reflow_state, #1
1440 803D       331            sjmp End_master_ISR
1442            332   
1442            333   
1442            334   
1442            335   STOP_ROUTINE: 
1442 755005     336            mov reflow_state, #5    
1445            337            ; any other things we want to do, ie, statements we want to make 
1445            338   
1445 C0E0       339            push acc
1447 7401       339            mov a, #1
1449 14         339            dec a
144A 120293     339            lcall ?Set_Cursor_1 ; Select column and row
144D D0E0       339            pop acc
144F C083       340            push dph
1451 C082       340            push dpl
1453 C0E0       340            push acc
1455 9001DE     340            mov dptr, #Abort_string
1458 120286     340            lcall ?Send_Constant_String
145B D0E0       340            pop acc
145D D082       340            pop dpl
145F D083       340            pop dph
1461            341   
1461 C0E0       342            push acc
1463 7401       342            mov a, #1
1465 14         342            dec a
1466 120291     342            lcall ?Set_Cursor_2 ; Select column and row
1469 D0E0       342            pop acc
146B C083       343            push dph
146D C082       343            push dpl
146F C0E0       343            push acc
1471 9001EF     343            mov dptr, #Waiting_to_cool
1474 120286     343            lcall ?Send_Constant_String
1477 D0E0       343            pop acc
1479 D082       343            pop dpl
147B D083       343            pop dph
147D            344   
147D 8000       345   sjmp End_master_ISR
147F            346   
147F            347   
147F            348   End_master_ISR: 
147F 759E03     349            mov KBF, #3             ; enables interrupt
1482 D0E0       350            pop acc
1484            351   
1484 32         352            reti
1485            353   
1485            354   
1485            355   MainProgram:
1485 75817F     356       mov SP, #7FH ; Set the stack pointer to the begining of idata
1488 1213FC     357       lcall Start_stop_Init
148B 121365     358       lcall Timer0_Init
148E 121381     359            lcall Timer1_Init
1491 1213A0     360       lcall Timer2_Init
1494 121347     361            lcall seg_state_init
1497 755000     362            mov reflow_state, #0
149A            363       ; In case you decide to use the pins of P0, configure the port in bidirectional mode:
149A 75E600     364       mov P0M0, #0
149D 75E700     365       mov P0M1, #0
14A0            366            
14A0 758E11     367            mov AUXR, #00010001B ; Max memory.  P4.4 is a general purpose IO pin
14A3            368   
14A3 D2AF       369       setb EA   ; Enable Global interrupts
14A5            370            
14A5 120CF0     371            lcall INIT_SPI
14A8 12025A     372       lcall LCD_4BIT
14AB            373            
14AB            374            
14AB            375   forever:
14AB            376            ;lcall GET_TEMP_DATA     ;This is the lab3 derivative loop that grabs the data from the thermocouple, 
14AB 021061     377            ljmp reflow_state_machine       ; go do some stuff in the state_machine
14AE            378   
14AE            379   
14AE 0214AB     380       ljmp forever ; This is equivalent to 'forever: sjmp forever'
14B1            381   
14B1            382       
14B1            383   EN
