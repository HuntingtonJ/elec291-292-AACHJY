                 -1   $MODLP51
0000              1   ;--------------------------------------------------------
0000              2   ; Special Function Registers
0000              3   ;--------------------------------------------------------
0000              4   ACC            DATA 0xe0
0000              5   B              DATA 0xf0
0000              6   PSW            DATA 0xd0
0000              7   SP             DATA 0x81
0000              8   SPX            DATA 0xef
0000              9   DPL            DATA 0x82
0000             10   DPH            DATA 0x83
0000             11   DPLB           DATA 0xd4
0000             12   DPHB           DATA 0xd5
0000             13   PAGE           DATA 0xf6
0000             14   AX             DATA 0xe1
0000             15   BX             DATA 0xf7
0000             16   DSPR           DATA 0xe2
0000             17   FIRD           DATA 0xe3
0000             18   MACL           DATA 0xe4
0000             19   MACH           DATA 0xe5
0000             20   PCON           DATA 0x87
0000             21   AUXR           DATA 0x8e
0000             22   AUXR1          DATA 0xa2
0000             23   DPCF           DATA 0xa1
0000             24   CKRL           DATA 0x97
0000             25   CKCKON0        DATA 0x8f
0000             26   CKCKON1        DATA 0xaf
0000             27   CKSEL          DATA 0x85
0000             28   CLKREG         DATA 0xae
0000             29   OSCCON         DATA 0x85
0000             30   IE             DATA 0xa8
0000             31   IEN0           DATA 0xa8
0000             32   IEN1           DATA 0xb1
0000             33   IPH0           DATA 0xb7
0000             34   IP             DATA 0xb8
0000             35   IPL0           DATA 0xb8
0000             36   IPH1           DATA 0xb3
0000             37   IPL1           DATA 0xb2
0000             38   P0             DATA 0x80
0000             39   P1             DATA 0x90
0000             40   P2             DATA 0xa0
0000             41   P3             DATA 0xb0
0000             42   P4             DATA 0xc0
0000             43   P0M0           DATA 0xe6
0000             44   P0M1           DATA 0xe7
0000             45   P1M0           DATA 0xd6
0000             46   P1M1           DATA 0xd7
0000             47   P2M0           DATA 0xce
0000             48   P2M1           DATA 0xcf
0000             49   P3M0           DATA 0xc6
0000             50   P3M1           DATA 0xc7
0000             51   P4M0           DATA 0xbe
0000             52   P4M1           DATA 0xbf
0000             53   SCON           DATA 0x98
0000             54   SBUF           DATA 0x99
0000             55   SADEN          DATA 0xb9
0000             56   SADDR          DATA 0xa9
0000             57   BDRCON         DATA 0x9b
0000             58   BRL            DATA 0x9a
0000             59   TCON           DATA 0x88
0000             60   TMOD           DATA 0x89
0000             61   TCONB          DATA 0x91
0000             62   TL0            DATA 0x8a
0000             63   TH0            DATA 0x8c
0000             64   TL1            DATA 0x8b
0000             65   TH1            DATA 0x8d
0000             66   RL0            DATA 0xf2
0000             67   RL1            DATA 0xf3
0000             68   RH0            DATA 0xf4
0000             69   RH1            DATA 0xf5
0000             70   WDTRST         DATA 0xa6
0000             71   WDTPRG         DATA 0xa7
0000             72   T2CON          DATA 0xc8
0000             73   T2MOD          DATA 0xc9
0000             74   RCAP2H         DATA 0xcb
0000             75   RCAP2L         DATA 0xca
0000             76   TH2            DATA 0xcd
0000             77   TL2            DATA 0xcc
0000             78   SPCON          DATA 0xc3
0000             79   SPSTA          DATA 0xc4
0000             80   SPDAT          DATA 0xc5
0000             81   SSCON          DATA 0x93
0000             82   SSCS           DATA 0x94
0000             83   SSDAT          DATA 0x95
0000             84   SSADR          DATA 0x96
0000             85   KBLS           DATA 0x9c
0000             86   KBE            DATA 0x9d
0000             87   KBF            DATA 0x9e
0000             88   KBMOD          DATA 0x9f
0000             89   BMSEL          DATA 0x92
0000             90   FCON           DATA 0xd2
0000             91   EECON          DATA 0xd2
0000             92   ACSRA          DATA 0xa3
0000             93   ACSRB          DATA 0xab
0000             94   AREF           DATA 0xbd
0000             95   DADC           DATA 0xa4
0000             96   DADI           DATA 0xa5
0000             97   DADL           DATA 0xac
0000             98   DADH           DATA 0xad
0000             99   CCON           DATA 0xd8
0000            100   CMOD           DATA 0xd9
0000            101   CL             DATA 0xe9
0000            102   CH             DATA 0xf9
0000            103   CCAPM0         DATA 0xda
0000            104   CCAPM1         DATA 0xdb
0000            105   CCAPM2         DATA 0xdc
0000            106   CCAPM3         DATA 0xdd
0000            107   CCAPM4         DATA 0xde
0000            108   CCAP0H         DATA 0xfa
0000            109   CCAP1H         DATA 0xfb
0000            110   CCAP2H         DATA 0xfc
0000            111   CCAP3H         DATA 0xfd
0000            112   CCAP4H         DATA 0xfe
0000            113   CCAP0L         DATA 0xea
0000            114   CCAP1L         DATA 0xeb
0000            115   CCAP2L         DATA 0xec
0000            116   CCAP3L         DATA 0xed
0000            117   CCAP4L         DATA 0xee
0000            118   ;--------------------------------------------------------
0000            119   ; special function bits
0000            120   ;--------------------------------------------------------
0000            121   P              BIT 0xd0
0000            122   F1             BIT 0xd1
0000            123   OV             BIT 0xd2
0000            124   RS0            BIT 0xd3
0000            125   RS1            BIT 0xd4
0000            126   F0             BIT 0xd5
0000            127   AC             BIT 0xd6
0000            128   CY             BIT 0xd7
0000            129   EX0            BIT 0xa8
0000            130   ET0            BIT 0xa9
0000            131   EX1            BIT 0xaa
0000            132   ET1            BIT 0xab
0000            133   ES             BIT 0xac
0000            134   ET2            BIT 0xad
0000            135   EC             BIT 0xae
0000            136   EA             BIT 0xaf
0000            137   PX0            BIT 0xb8
0000            138   PT0            BIT 0xb9
0000            139   PX1            BIT 0xba
0000            140   PT1            BIT 0xbb
0000            141   PS             BIT 0xbc
0000            142   PT2            BIT 0xbd
0000            143   IP0D           BIT 0xbf
0000            144   PPCL           BIT 0xbe
0000            145   PT2L           BIT 0xbd
0000            146   PLS            BIT 0xbc
0000            147   PT1L           BIT 0xbb
0000            148   PX1L           BIT 0xba
0000            149   PT0L           BIT 0xb9
0000            150   PX0L           BIT 0xb8
0000            151   RXD            BIT 0xb0
0000            152   TXD            BIT 0xb1
0000            153   INT0           BIT 0xb2
0000            154   INT1           BIT 0xb3
0000            155   T0             BIT 0xb4
0000            156   T1             BIT 0xb5
0000            157   WR             BIT 0xb6
0000            158   RD             BIT 0xb7
0000            159   RI             BIT 0x98
0000            160   TI             BIT 0x99
0000            161   RB8            BIT 0x9a
0000            162   TB8            BIT 0x9b
0000            163   REN            BIT 0x9c
0000            164   SM2            BIT 0x9d
0000            165   SM1            BIT 0x9e
0000            166   SM0            BIT 0x9f
0000            167   IT0            BIT 0x88
0000            168   IE0            BIT 0x89
0000            169   IT1            BIT 0x8a
0000            170   IE1            BIT 0x8b
0000            171   TR0            BIT 0x8c
0000            172   TF0            BIT 0x8d
0000            173   TR1            BIT 0x8e
0000            174   TF1            BIT 0x8f
0000            175   CP_RL2         BIT 0xc8
0000            176   C_T2           BIT 0xc9
0000            177   TR2            BIT 0xca
0000            178   EXEN2          BIT 0xcb
0000            179   TCLK           BIT 0xcc
0000            180   RCLK           BIT 0xcd
0000            181   EXF2           BIT 0xce
0000            182   TF2            BIT 0xcf
0000            183   CF             BIT 0xdf
0000            184   CR             BIT 0xde
0000            185   CCF4           BIT 0xdc
0000            186   CCF3           BIT 0xdb
0000            187   CCF2           BIT 0xda
0000            188   CCF1           BIT 0xd9
0000            189   CCF0           BIT 0xd8
0000              2   
0000              3   ; There is a couple of typos in MODLP51 in the definition of the timer 0/1 reload
0000              4   ; special function registers (SFRs), so:
0000              5   
0000              6   TIMER0_RELOAD_L DATA 0xf2
0000              7   TIMER1_RELOAD_L DATA 0xf3
0000              8   TIMER0_RELOAD_H DATA 0xf4
0000              9   TIMER1_RELOAD_H DATA 0xf5
0000             10   
0000             11   CLK              EQU 22118400 ; Microcontroller system crystal frequency in Hz
0000             12   TIMER0_RATE      EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             13   TIMER0_RELOAD    EQU ((65536-(CLK/TIMER0_RATE)))
0000             14   TIMER2_RATE      EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             15   TIMER2_RELOAD    EQU ((65536-(CLK/TIMER2_RATE)))
0000             16   MAX_TEMP              EQU 250
0000             17   TIMEOUT_TIME     EQU 60
0000             18   BAUD             EQU 115200
0000             19   BRG_VAL          EQU (0x100-(CLK/(16*BAUD)))
0000             20   MILLISECOND_WAIT EQU 200                 ; how many milliseconds between temp samples
0000             21   
0000             22   DUTY_0           EQU 0
0000             23   DUTY_20          EQU 51   ;256 * 0.2
0000             24   DUTY_50          EQU 128  ;256 * 0.5
0000             25   DUTY_80          EQU 204  ;256 * 0.8
0000             26   DUTY_100         EQU 255
0000             27   
0000             28   org 0x0000
0000 021D15      29      ljmp MainProgram
0003             30   
0003             31   ; External interrupt 0 vector (not used in this code)
0003             32   org 0x0003
0003 32          33            reti
0004             34   
0004             35   ; Timer/Counter 0 overflow interrupt vector
000B             36   org 0x000B
000B 021AA2      37            ljmp Timer0_ISR
000E             38   
000E             39   ; External interrupt 1 vector (not used in this code)
0013             40   org 0x0013
0013 32          41            reti
0014             42   
0014             43   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             44   org 0x001B
001B 32          45            reti
001C             46   
001C             47   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             48   org 0x0023 
0023 32          49            reti
0024             50            
0024             51   ; Timer/Counter 2 overflow interrupt vector
002B             52   org 0x002B
002B 021ADD      53            ljmp Timer2_ISR
002E             54   
002E             55   ;Edge triggered keyboard interrupt vector
003B             56   org 0x003B
003B 021B2A      57            ljmp Start_stop_ISR
003E             58   
003E             59   ; These ’EQU’ must match the wiring between the microcontroller and ADC
003E             60   SOUND_OUT     EQU P3.7
003E             61   CE_ADC        EQU P2.0
003E             62   MY_MOSI       EQU P2.1
003E             63   MY_MISO       EQU P2.2
003E             64   MY_SCLK       EQU P2.3
003E             65   
003E             66   UP_BUTTON          EQU P2.6 
003E             67   DOWN_BUTTON   EQU P2.5
003E             68   SELECT_BUTTON equ P2.4
003E             69   BACK_BUTTON   EQU #11110000B
003E             70   MASTER_START  EQU #10100000B 
003E             71   MASTER_STOP   EQU #10110000B
003E             72   
003E             73   ; For the 7-segment display
003E             74   SEGA equ P0.3
003E             75   SEGB equ P0.5
003E             76   SEGC equ P0.7
003E             77   SEGD equ P4.4
003E             78   SEGE equ P4.5
003E             79   SEGF equ P0.4
003E             80   SEGG equ P0.6
003E             81   SEGP equ P2.7
003E             82   CA1  equ P0.1
003E             83   CA2  equ P0.0
003E             84   CA3  equ P0.2
003E             85   
003E             86   ; For the LCD
003E             87   LCD_RS equ P1.1
003E             88   LCD_RW equ P1.2
003E             89   LCD_E  equ P1.3
003E             90   LCD_D4 equ P3.2
003E             91   LCD_D5 equ P3.3
003E             92   LCD_D6 equ P3.4
003E             93   LCD_D7 equ P3.6
003E             94   
003E             95   ; pins to be used on the MPC 3008
003E             96   adc_zero                 equ #10000000B               ; LM355 temp sensor 
003E             97   adc_one                  equ #10010000B               ; thermocouple
003E             98   adc_two                  equ #10100000B               ;  start
003E             99   adc_three                equ #10110000B               ;  stop
003E            100   adc_four                 equ #11000000B               ;  
003E            101   adc_five                 equ #11010000B               ;  
003E            102   adc_six                  equ #11100000B               ; 
003E            103   adc_seven                equ #11110000B                           ; back
003E            104   
0030            105   DSEG at 0x30
0030            106   Count1ms:       ds 2 ; Used to determine when half second has passed
0032            107   Result:         ds 2 ; Temp from lm355
0034            108   Result_Thermo:  ds 2 ; Temp from Thermocoupler
0036            109   ADC_Result:     ds 2 ; Temp from ADC channel 2
0038            110   
0038            111   BCD_temp:       ds 2 ; Used to diplay temp on the 7-segment display
003A            112   seconds:        ds 1
003B            113   x:              ds 4 ; Used in math32
003F            114   y:              ds 4 ; Used in math32
0043            115   bcd:            ds 5
0048            116   soaktime:       ds 2
004A            117   soaktemp:       ds 2
004C            118   reflowtime:     ds 2
004E            119   reflowtemp:     ds 2
0050            120   soaktemp3digit: ds 2
0052            121   reflow_state:   ds 1
0053            122   pwm:            ds 1
0054            123   temp:           ds 1
0055            124   sec:            ds 1 ; seconds variable for reflow FSM (to be incremented every second)
0056            125   cooled_temp:    ds 1
0057            126   ; 7-segment vars
0057            127   disp1:          ds 1 ; Least significant digit
0058            128   disp2:          ds 1
0059            129   disp3:          ds 1 ; Most significant digit
005A            130   seg_state:      ds 1 ; state of 7_seg fsm
005B            131   display_scratch: ds 1
005C            132   
005C            133   
005C            134   
0000            135   BSEG
0000            136   mf: dbit 1
0001            137   one_second_flag: dbit 1 
0002            138   shortbeepflag: dbit 1
0003            139   longbeepflag: dbit 1
0004            140   sixbeepflag: dbit 1
0005            141   
0005            142   
003E            143   CSEG
003E            144                    ;                        1234567890123456
003E 20202020   145   Ramp_to_Soak:    db       '         Preheat', 0
     20202020
     20507265
     68656174
     00
004F 20202020   146   Soak:                    db   '         Soak   ', 0
     20202020
     20536F61
     6B202020
     00
0060 20202020   147   Ramp_to_Peak:    db       '         Ramp2pk', 0
     20202020
     2052616D
     7032706B
     00
0071 20202020   148   Reflow:                  db       '         Reflow ', 0
     20202020
     20526566
     6C6F7720
     00
0082 20202020   149   Cooling:                 db       '         Cooling', 0
     20202020
     20436F6F
     6C696E67
     00
0093 7300       150   secondsss:               db   's'                , 0
0095            151   ;                     1234567890123456    <- This helps determine the location of the counter
0095 57656C63   152   Welcome:                   db 'Welcome!        ', 0
     6F6D6521
     20202020
     20202020
     00
00A6 53656C65   153   Choose_option:     db 'Select option   ', 0
     6374206F
     7074696F
     6E202020
     00
00B7 50726573   154   Preset_menu_msg:  db 'Preset Profile  ', 0
     65742050
     726F6669
     6C652020
     00
00C8 43757374   155   Custom_menu_msg:  db 'Custom Profile  ', 0
     6F6D2050
     726F6669
     6C652020
     00
00D9 536F616B   156   Soak_temp:                 db 'Soak Temp       ', 0
     2054656D
     70202020
     20202020
     00
00EA 536F616B   157   Soak_time:                 db 'Soak Time       ', 0
     2054696D
     65202020
     20202020
     00
00FB 5265666C   158   Reflow_time:       db 'Reflow Time     ', 0
     6F772054
     696D6520
     20202020
     00
010C 5265666C   159   Reflow_temp:       db 'Reflow Temp     ', 0
     6F772054
     656D7020
     20202020
     00
011D 53414333   160   Pb_free_solder:    db 'SAC305 solder   ', 0
     30352073
     6F6C6465
     72202020
     00
012E 50622D73   161   Pb_solder:                 db 'Pb-solder paste ', 0
     6F6C6465
     72207061
     73746520
     00
013F 53686868   162   Pizza_msg0:        db 'Shhh! No pizza  ', 0
     21204E6F
     2070697A
     7A612020
     00
0150 616C6C6F   163   Pizza_msg1:        db 'allowed in here.', 0
     77656420
     696E2068
     6572652E
     00
0161 70726F66   164   Profile_loaded:   db 'profile loaded  ', 0
     696C6520
     6C6F6164
     65642020
     00
0172 53797374   165   Is_ready:                  db 'System Ready    ', 0
     656D2052
     65616479
     20202020
     00
0183 50726573   166   Press_start:       db 'Press Start     ', 0
     73205374
     61727420
     20202020
     00
0194 78782020   167   Set_Value:                 db 'xx              ', 0
     20202020
     20202020
     20202020
     00
01A5 20202020   168   Clear_Row:                 db '                ', 0
     20202020
     20202020
     20202020
     00
01B6 41542050   169   PRESETMENUMSG:     db 'AT PRESET MENU  ', 0
     52455345
     54204D45
     4E552020
     00
01C7 41542043   170   CUSTOMMENUMSG:     db 'AT CUSTOM MENU  ', 0
     5553544F
     4D204D45
     4E552020
     00
01D8 41726520   171   Are_you_sure:      db 'Are you sure?   ', 0
     796F7520
     73757265
     3F202020
     00
01E9 4572726F   172   Error_msg1:        db 'Error, profiles ', 0
     722C2070
     726F6669
     6C657320
     00
01FA 6E6F7420   173   Error_msg2:       db 'not loaded      ', 0
     6C6F6164
     65642020
     20202020
     00
020B 50726F63   174   Abort_string:      db 'Process aborted ', 0
     65737320
     61626F72
     74656420
     00
021C 57616974   175   Waiting_to_cool:  db 'Wait to cool    ', 0
     20746F20
     636F6F6C
     20202020
     00
022D 49535220   176   ISR_is_running:   db 'ISR is running  ', 0
     69732072
     756E6E69
     6E672020
     00
023E            177   
023E 53746174   178   State_0: db 'State 0', 0
     65203000
0246 53746174   179   State_1: db 'State 1', 0
     65203100
024E            180   
024E C0F9A4B0   181   HEX_7SEG: DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90
     999282F8
     8090
0258            182   
0258            183   
                185   	$LIST
0306            187   
                546   $LIST
                189   $LIST
0576            191   
                193   $LIST
1397            195   
                197   $LIST
1786            199   
                201   $LIST
1A07            203   
                205   $LIST
1A89            207   
1A89            208   ;----------------------------------------MACRO LOCATION----------------------------------------------
1A89            209   
1A89            210   
1A89            211   
1A89            212   
1A89            213   ;---------------------------------;
1A89            214   ; Routine to initialize the ISR   ;
1A89            215   ; for timer 0                     ;
1A89            216   ;---------------------------------;
1A89            217   Timer0_Init:
1A89 E589       218            mov a, TMOD
1A8B 54F0       219            anl a, #0xf0 ; Clear the bits for timer 0
1A8D 4401       220            orl a, #0x01 ; Configure timer 0 as 16-timer
1A8F F589       221            mov TMOD, a
1A91 758CEA     222            mov TH0, #high(TIMER0_RELOAD)
1A94 758AE8     223            mov TL0, #low(TIMER0_RELOAD)
1A97            224            ; Set autoreload value
1A97 75F4EA     225            mov TIMER0_RELOAD_H, #high(TIMER0_RELOAD)
1A9A 75F2E8     226            mov TIMER0_RELOAD_L, #low(TIMER0_RELOAD)
1A9D            227            ; Enable the timer and interrupts
1A9D D2A9       228       setb ET0  ; Enable timer 0 interrupt
1A9F D28C       229       setb TR0  ; Start timer 0
1AA1 22         230            ret
1AA2            231   
1AA2            232   ;---------------------------------;
1AA2            233   ; ISR for timer 0.  Set to execute;
1AA2            234   ; every 1/4096Hz to generate a    ;
1AA2            235   ; 2048 Hz square wave at pin P3.7 ;
1AA2            236   ;---------------------------------;
1AA2            237   Timer0_ISR:
1AA2            238            ;clr TF0  ; According to the data sheet this is done for us already.
1AA2 8000       239            sjmp no_beep
1AA4            240   beep_on:
1AA4            241            ;cpl SOUND_OUT ; Connect speaker to P3.7!
1AA4            242   no_beep:
1AA4 32         243            reti
1AA5            244            
1AA5            245   ;---------------------------------;
1AA5            246   ; Routine to initialize the ISR   ;
1AA5            247   ; for timer 1 in PWM mode         ;
1AA5            248   ;---------------------------------;
1AA5            249   
1AA5            250   Timer1_Init:
1AA5 E589       251            mov a, TMOD
1AA7 540F       252            anl a, #00001111B       ;Clears timer 1 settings but keeps timer 0 settings
1AA9 4410       253            orl a, #00010000B       ;Gate = 0, TC1 = 0, mode = 01 (mode 1)
1AAB F589       254            mov TMOD, a
1AAD            255            
1AAD E591       256            mov a, TCONB            ;load TCONB for PWM settings
1AAF 5400       257            anl a, #00000000B       ;clear TCONB
1AB1 4480       258            orl a, #10000000B       ;Set PWM1 = 1
1AB3 F591       259            mov TCONB, a
1AB5            260            
1AB5 758D00     261            mov TH1, #0             ;Current count value
1AB8 758B00     262            mov TL1, #0             ;Linear Prescaling
1ABB            263            
1ABB 75F500     264            mov TIMER1_RELOAD_H, #DUTY_0 ;Duty cycle percentage. Replace this value to change the duty cycle
1ABE 75F300     265            mov TIMER1_RELOAD_L, #0      ;Frequency scaling/adjust f_out = f_sys/(256 * (256 - TL))
1AC1            266            
1AC1 D28E       267            setb TR1
1AC3 32         268            reti
1AC4            269   
1AC4            270   ;---------------------------------;
1AC4            271   ; Routine to initialize the ISR   ;
1AC4            272   ; for timer 2                     ;
1AC4            273   ;---------------------------------;
1AC4            274   Timer2_Init:
1AC4 75C800     275            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
1AC7 75CDA9     276            mov TH2, #high(TIMER2_RELOAD)
1ACA 75CC9A     277            mov TL2, #low(TIMER2_RELOAD)
1ACD            278            ; Set the reload value
1ACD 75CBA9     279            mov RCAP2H, #high(TIMER2_RELOAD)
1AD0 75CA9A     280            mov RCAP2L, #low(TIMER2_RELOAD)
1AD3            281            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
1AD3 E4         282            clr a
1AD4 F530       283            mov Count1ms+0, a
1AD6 F531       284            mov Count1ms+1, a
1AD8            285            ; Enable the timer and interrupts
1AD8 D2AD       286       setb ET2  ; Enable timer 2 interrupt
1ADA D2CA       287       setb TR2  ; Enable timer 2
1ADC 22         288            ret
1ADD            289   
1ADD            290   ;---------------------------------;
1ADD            291   ; ISR for timer 2                 ;
1ADD            292   ;---------------------------------;
1ADD            293   Timer2_ISR:
1ADD C2CF       294            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
1ADF            295   
1ADF            296            ; The two registers used in the ISR must be saved in the stack
1ADF C0E0       297            push acc
1AE1 C0D0       298            push psw
1AE3 121A28     299            lcall seg_state_machine
1AE6            300            ; Increment the 16-bit one mili second counter
1AE6            301                            ;       inc Count1ms+0    ; Increment the low 8-bits first
1AE6            302                                    ;mov a, Count1ms+0
1AE6            303                            ;       cjne a, #10h, Timer2_ISR_done
1AE6            304                            ;       mov Count1ms+0, #0h
1AE6 0530       305            inc Count1ms+0    ; Increment the low 8-bits first
1AE8 E530       306            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
1AEA 7015       307            jnz Inc_Done
1AEC 0531       308            inc Count1ms+1
1AEE            309            
1AEE C000       310            push ar0
1AF0 A843       310            mov r0, bcd
1AF2 121625     310            lcall ?Send_BCD
1AF5 740D       310            mov a, #'\r'
1AF7 1213AF     310       lcall putchar
1AFA 740A       310       mov a, #'\n'
1AFC 1213AF     310       lcall putchar
1AFF D000       310            pop ar0
1B01            311            Inc_Done:
1B01            312            ; Check if a second has passed
1B01            313   
1B01 E530       314            mov a, Count1ms+0
1B03 B4C815     315            cjne a, #low(MILLISECOND_WAIT), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
1B06 E531       316            mov a, Count1ms+1
1B08 B40010     317            cjne a, #high(MILLISECOND_WAIT), Timer2_ISR_done
1B0B            318            
1B0B            319            ; 1000 milliseconds have passed.  Set a flag so the main program knows
1B0B D201       320            setb one_second_flag ; Let the main program know one second had passed
1B0D B28C       321            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
1B0F            322            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
1B0F E4         323            clr a
1B10 F530       324            mov Count1ms+0, a
1B12 F531       325            mov Count1ms+1, a
1B14            326            ; Increment the BCD counter
1B14 E53A       327            mov a, seconds
1B16 2401       328            add a, #0x01
1B18 D4         329            da a ; Decimal adjust instruction.  Check datasheet for more details!
1B19 F53A       330            mov seconds, a
1B1B            331            
1B1B            332   Timer2_ISR_done:
1B1B D0D0       333            pop psw
1B1D D0E0       334            pop acc
1B1F 32         335            reti
1B20            336   
1B20            337   
1B20            338   ;-------------------------------------
1B20            339   ; To start or ABORT the reflow cycle
1B20            340   ;------------------------------------
1B20            341   Start_stop_Init: 
1B20            342            
1B20 759F01     343            mov KBMOD, #0x01        ; enable edge triggered for P0.0 and P0.1
1B23 759C00     344            mov KBLS, #0x00         ; watch for negative edge (0->1)
1B26 759D01     345            mov KBE, #0x01  ; enable interrupt for p0.0 and p0.1
1B29            346   ;        mov KBF, #0x01 ; interrupt active, must clear at start of ISR and setb at end. 
1B29            347   
1B29 22         348            ret
1B2A            349   
1B2A            350   Start_stop_ISR: 
1B2A 759E00     351            mov KBF, #0             ; masks interrupt 
1B2D C0E0       352            push acc
1B2F            353   
1B2F C2A0       354            clr CE_ADC         ; selects 
1B31 7801       354       mov R0, #00000001B ; Start bit: 1
1B33 1213C7     354       lcall DO_SPI_G
1B36            354       
1B36 78B0       354       mov R0, MASTER_STOP ; Read channel
1B38 1213C7     354       lcall DO_SPI_G
1B3B E9         354       mov a, R1
1B3C 5403       354       anl a, #00000011B
1B3E F537       354       mov ADC_Result+1, a    ; Save high result
1B40            354       
1B40 7855       354       mov R0, #55H
1B42 1213C7     354       lcall DO_SPI_G
1B45 8936       354       mov ADC_Result+0, R1     ; Save low result
1B47            354       
1B47 D2A0       354       setb CE_ADC        ; deselects
1B49            354       
1B49            354       ;V_OUT = ADC_voltage*4.096V/1023
1B49 85363B     354       mov x+0, ADC_Result
1B4C 85373C     354       mov x+1, ADC_Result+1
1B4F 753D00     354       mov x+2, #0
1B52 753E00     354       mov x+3, #0
1B55            354       
1B55 753FFB     354            mov y+0, #low (4091 % 0x10000) 
1B58 75400F     354            mov y+1, #high(4091 % 0x10000) 
1B5B 754100     354            mov y+2, #low (4091 / 0x10000) 
1B5E 754200     354            mov y+3, #high(4091 / 0x10000) 
1B61 120480     354       lcall mul32 ;multiplies x *= y
1B64            354       
1B64 753FFF     354            mov y+0, #low (1023 % 0x10000) 
1B67 754003     354            mov y+1, #high(1023 % 0x10000) 
1B6A 754100     354            mov y+2, #low (1023 / 0x10000) 
1B6D 754200     354            mov y+3, #high(1023 / 0x10000) 
1B70 12050D     354       lcall div32 ;divides x /= y
1B73            354       
1B73 753FE8     354            mov y+0, #low (1000 % 0x10000) 
1B76 754003     354            mov y+1, #high(1000 % 0x10000) 
1B79 754100     354            mov y+2, #low (1000 / 0x10000) 
1B7C 754200     354            mov y+3, #high(1000 / 0x10000) 
1B7F 12050D     354       lcall div32
1B82            354       
1B82 853C37     354       mov ADC_Result+1, x+1
1B85 853B36     354       mov ADC_Result+0, x+0
1B88            354            ; loads ADC_Result (16 bit) with voltage value of pressed button 
1B88 E536       354            mov a, ADC_Result+0
1B8A B40002     354            cjne a, #0, wait_release_306
1B8D            354   
1B8D 8061       354            sjmp endhere_306
1B8F            354   wait_release_306:
1B8F C2A0       354            clr CE_ADC         ; selects 
1B91 7801       354       mov R0, #00000001B ; Start bit: 1
1B93 1213C7     354       lcall DO_SPI_G
1B96            354       
1B96 78B0       354       mov R0, MASTER_STOP ; Read channel
1B98 1213C7     354       lcall DO_SPI_G
1B9B E9         354       mov a, R1
1B9C 5403       354       anl a, #00000011B
1B9E F537       354       mov ADC_Result+1, a    ; Save high result
1BA0            354       
1BA0 7855       354       mov R0, #55H
1BA2 1213C7     354       lcall DO_SPI_G
1BA5 8936       354       mov ADC_Result+0, R1     ; Save low result
1BA7            354       
1BA7 D2A0       354       setb CE_ADC        ; deselects
1BA9            354       
1BA9            354       ;V_OUT = ADC_voltage*4.096V/1023
1BA9 85363B     354       mov x+0, ADC_Result
1BAC 85373C     354       mov x+1, ADC_Result+1
1BAF 753D00     354       mov x+2, #0
1BB2 753E00     354       mov x+3, #0
1BB5            354       
1BB5 753FFB     354            mov y+0, #low (4091 % 0x10000) 
1BB8 75400F     354            mov y+1, #high(4091 % 0x10000) 
1BBB 754100     354            mov y+2, #low (4091 / 0x10000) 
1BBE 754200     354            mov y+3, #high(4091 / 0x10000) 
1BC1 120480     354       lcall mul32 ;multiplies x *= y
1BC4            354       
1BC4 753FFF     354            mov y+0, #low (1023 % 0x10000) 
1BC7 754003     354            mov y+1, #high(1023 % 0x10000) 
1BCA 754100     354            mov y+2, #low (1023 / 0x10000) 
1BCD 754200     354            mov y+3, #high(1023 / 0x10000) 
1BD0 12050D     354       lcall div32 ;divides x /= y
1BD3            354       
1BD3 753FE8     354            mov y+0, #low (1000 % 0x10000) 
1BD6 754003     354            mov y+1, #high(1000 % 0x10000) 
1BD9 754100     354            mov y+2, #low (1000 / 0x10000) 
1BDC 754200     354            mov y+3, #high(1000 / 0x10000) 
1BDF 12050D     354       lcall div32
1BE2            354       
1BE2 853C37     354       mov ADC_Result+1, x+1
1BE5 853B36     354       mov ADC_Result+0, x+0
1BE8            354            ; loads ADC_Result (16 bit) with voltage value of pressed button 
1BE8 E536       354            mov a, ADC_Result+0
1BEA B400A2     354            cjne a, #0,wait_release_306
1BED 021CD5     354            ljmp STOP_ROUTINE
1BF0            354            endhere_306:    ; if master stop has been pressed, change to state 5
1BF0 C2A0       355            clr CE_ADC         ; selects 
1BF2 7801       355       mov R0, #00000001B ; Start bit: 1
1BF4 1213C7     355       lcall DO_SPI_G
1BF7            355       
1BF7 78A0       355       mov R0, MASTER_START ; Read channel
1BF9 1213C7     355       lcall DO_SPI_G
1BFC E9         355       mov a, R1
1BFD 5403       355       anl a, #00000011B
1BFF F537       355       mov ADC_Result+1, a    ; Save high result
1C01            355       
1C01 7855       355       mov R0, #55H
1C03 1213C7     355       lcall DO_SPI_G
1C06 8936       355       mov ADC_Result+0, R1     ; Save low result
1C08            355       
1C08 D2A0       355       setb CE_ADC        ; deselects
1C0A            355       
1C0A            355       ;V_OUT = ADC_voltage*4.096V/1023
1C0A 85363B     355       mov x+0, ADC_Result
1C0D 85373C     355       mov x+1, ADC_Result+1
1C10 753D00     355       mov x+2, #0
1C13 753E00     355       mov x+3, #0
1C16            355       
1C16 753FFB     355            mov y+0, #low (4091 % 0x10000) 
1C19 75400F     355            mov y+1, #high(4091 % 0x10000) 
1C1C 754100     355            mov y+2, #low (4091 / 0x10000) 
1C1F 754200     355            mov y+3, #high(4091 / 0x10000) 
1C22            355   
1C22 120480     355       lcall mul32 ;multiplies x *= y
1C25            355       
1C25 753FFF     355            mov y+0, #low (1023 % 0x10000) 
1C28 754003     355            mov y+1, #high(1023 % 0x10000) 
1C2B 754100     355            mov y+2, #low (1023 / 0x10000) 
1C2E 754200     355            mov y+3, #high(1023 / 0x10000) 
1C31 12050D     355       lcall div32 ;divides x /= y
1C34            355       
1C34 753FE8     355            mov y+0, #low (1000 % 0x10000) 
1C37 754003     355            mov y+1, #high(1000 % 0x10000) 
1C3A 754100     355            mov y+2, #low (1000 / 0x10000) 
1C3D 754200     355            mov y+3, #high(1000 / 0x10000) 
1C40 12050D     355       lcall div32
1C43            355       
1C43 853C37     355       mov ADC_Result+1, x+1
1C46 853B36     355       mov ADC_Result+0, x+0
1C49            355            ; loads ADC_Result (16 bit) with voltage value of pressed button 
1C49 E536       355            mov a, ADC_Result+0
1C4B B40002     355            cjne a, #0, wait_release_315
1C4E            355   
1C4E 8061       355            sjmp endhere_315
1C50            355   wait_release_315:
1C50 C2A0       355            clr CE_ADC         ; selects 
1C52 7801       355       mov R0, #00000001B ; Start bit: 1
1C54 1213C7     355       lcall DO_SPI_G
1C57            355       
1C57 78A0       355       mov R0, MASTER_START ; Read channel
1C59 1213C7     355       lcall DO_SPI_G
1C5C E9         355       mov a, R1
1C5D 5403       355       anl a, #00000011B
1C5F F537       355       mov ADC_Result+1, a    ; Save high result
1C61            355       
1C61 7855       355       mov R0, #55H
1C63 1213C7     355       lcall DO_SPI_G
1C66 8936       355       mov ADC_Result+0, R1     ; Save low result
1C68            355       
1C68 D2A0       355       setb CE_ADC        ; deselects
1C6A            355       
1C6A            355       ;V_OUT = ADC_voltage*4.096V/1023
1C6A 85363B     355       mov x+0, ADC_Result
1C6D 85373C     355       mov x+1, ADC_Result+1
1C70 753D00     355       mov x+2, #0
1C73 753E00     355       mov x+3, #0
1C76            355       
1C76 753FFB     355            mov y+0, #low (4091 % 0x10000) 
1C79 75400F     355            mov y+1, #high(4091 % 0x10000) 
1C7C 754100     355            mov y+2, #low (4091 / 0x10000) 
1C7F 754200     355            mov y+3, #high(4091 / 0x10000) 
1C82            355   
1C82 120480     355       lcall mul32 ;multiplies x *= y
1C85            355       
1C85 753FFF     355            mov y+0, #low (1023 % 0x10000) 
1C88 754003     355            mov y+1, #high(1023 % 0x10000) 
1C8B 754100     355            mov y+2, #low (1023 / 0x10000) 
1C8E 754200     355            mov y+3, #high(1023 / 0x10000) 
1C91 12050D     355       lcall div32 ;divides x /= y
1C94            355       
1C94 753FE8     355            mov y+0, #low (1000 % 0x10000) 
1C97 754003     355            mov y+1, #high(1000 % 0x10000) 
1C9A 754100     355            mov y+2, #low (1000 / 0x10000) 
1C9D 754200     355            mov y+3, #high(1000 / 0x10000) 
1CA0 12050D     355       lcall div32
1CA3            355       
1CA3 853C37     355       mov ADC_Result+1, x+1
1CA6 853B36     355       mov ADC_Result+0, x+0
1CA9            355            ; loads ADC_Result (16 bit) with voltage value of pressed button 
1CA9 E536       355            mov a, ADC_Result+0
1CAB B400A2     355            cjne a, #0,wait_release_315
1CAE 021CB1     355            ljmp START_ROUTINE
1CB1            355            endhere_315: ; if master start has been pressed, change to state 1
1CB1            356   
1CB1            357   START_ROUTINE: 
1CB1            358            ; We should add some code here that 
1CB1 E4         359            clr a
1CB2 C0E0       360            push acc
1CB4 7401       360            mov a, #1
1CB6 14         360            dec a
1CB7 1202E9     360            lcall ?Set_Cursor_2 ; Select column and row
1CBA D0E0       360            pop acc
1CBC C083       361            push dph
1CBE C082       361            push dpl
1CC0 C0E0       361            push acc
1CC2 90022D     361            mov dptr, #ISR_is_running
1CC5 1202DE     361            lcall ?Send_Constant_String
1CC8 D0E0       361            pop acc
1CCA D082       361            pop dpl
1CCC D083       361            pop dph
1CCE E552       362            mov a, reflow_state
1CD0            363            ;cjne a, #0x00, End_master_ISR
1CD0 755201     364            mov reflow_state, #0x01
1CD3 803D       365            sjmp End_master_ISR
1CD5            366   
1CD5            367   
1CD5            368   
1CD5            369   STOP_ROUTINE: 
1CD5 755205     370            mov reflow_state, #5    
1CD8            371            ; any other things we want to do, ie, statements we want to make 
1CD8            372   
1CD8 C0E0       373            push acc
1CDA 7401       373            mov a, #1
1CDC 14         373            dec a
1CDD 1202EB     373            lcall ?Set_Cursor_1 ; Select column and row
1CE0 D0E0       373            pop acc
1CE2 C083       374            push dph
1CE4 C082       374            push dpl
1CE6 C0E0       374            push acc
1CE8 90020B     374            mov dptr, #Abort_string
1CEB 1202DE     374            lcall ?Send_Constant_String
1CEE D0E0       374            pop acc
1CF0 D082       374            pop dpl
1CF2 D083       374            pop dph
1CF4            375   
1CF4 C0E0       376            push acc
1CF6 7401       376            mov a, #1
1CF8 14         376            dec a
1CF9 1202E9     376            lcall ?Set_Cursor_2 ; Select column and row
1CFC D0E0       376            pop acc
1CFE C083       377            push dph
1D00 C082       377            push dpl
1D02 C0E0       377            push acc
1D04 90021C     377            mov dptr, #Waiting_to_cool
1D07 1202DE     377            lcall ?Send_Constant_String
1D0A D0E0       377            pop acc
1D0C D082       377            pop dpl
1D0E D083       377            pop dph
1D10            378   
1D10 8000       379            sjmp End_master_ISR
1D12            380   
1D12            381   
1D12            382   End_master_ISR: 
1D12            383   ;        mov KBF, #1             ; enables interrupt
1D12 D0E0       384            pop acc
1D14            385   
1D14 32         386            reti
1D15            387   
1D15            388   
1D15            389   MainProgram:
1D15 75817F     390       mov SP, #7FH ; Set the stack pointer to the begining of idata
1D18 121B20     391       lcall Start_stop_Init
1D1B 121A5F     392            lcall seg_state_init
1D1E 121A89     393       lcall Timer0_Init
1D21 121AA5     394            lcall Timer1_Init
1D24 121AC4     395       lcall Timer2_Init
1D27            396            
1D27 755200     397            mov reflow_state, #0x00
1D2A            398       ; In case you decide to use the pins of P0, configure the port in bidirectional mode:
1D2A 75E600     399       mov P0M0, #0
1D2D 75E700     400       mov P0M1, #0
1D30            401            
1D30 758E11     402            mov AUXR, #00010001B ; Max memory.  P4.4 is a general purpose IO pin
1D33            403   
1D33 D2AF       404       setb EA   ; Enable Global interrupts
1D35            405            
1D35 1213C2     406            lcall INIT_SPI
1D38 1202B2     407       lcall LCD_4BIT
1D3B            408       
1D3B            409   menu_forever:
1D3B 020593     410       ljmp Main_Menu_Program 
1D3E            411            
1D3E            412   forever:
1D3E 121774     413            lcall GET_TEMP_DATA      ;This is the lab3 derivative loop that grabs the data from the thermocouple, 
1D41 021786     414            ljmp reflow_state_machine       ; go do some stuff in the state_machine
1D44            415   
1D44 021D3E     416       ljmp forever ; This is equivalent to 'forever: sjmp forever'
1D47            417   
1D47            418       
1D47            419   EN
